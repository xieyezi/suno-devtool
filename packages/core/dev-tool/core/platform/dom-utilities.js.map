{
  "version": 3,
  "sources": ["../../../../../../front_end/core/platform/dom-utilities.ts"],
  "sourcesContent": ["// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/**\n * `document.activeElement` will not enter shadow roots to find the element\n * that has focus; use this method if you need to traverse through any shadow\n * roots to find the actual, specific focused element.\n */\nexport function deepActiveElement(doc: Document): Element|null {\n  let activeElement: Element|null = doc.activeElement;\n  while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement) {\n    activeElement = activeElement.shadowRoot.activeElement;\n  }\n  return activeElement;\n}\n\nexport function getEnclosingShadowRootForNode(node: Node): Node|null {\n  let parentNode = node.parentNodeOrShadowHost();\n  while (parentNode) {\n    if (parentNode instanceof ShadowRoot) {\n      return parentNode;\n    }\n    parentNode = parentNode.parentNodeOrShadowHost();\n  }\n  return null;\n}\n\nexport function rangeOfWord(\n    rootNode: Node, offset: number, stopCharacters: string, stayWithinNode: Node, direction?: string): Range {\n  let startNode;\n  let startOffset = 0;\n  let endNode;\n  let endOffset = 0;\n\n  if (!stayWithinNode) {\n    stayWithinNode = rootNode;\n  }\n\n  if (!direction || direction === 'backward' || direction === 'both') {\n    let node: Node|null = rootNode;\n    while (node) {\n      if (node === stayWithinNode) {\n        if (!startNode) {\n          startNode = stayWithinNode;\n        }\n        break;\n      }\n\n      if (node.nodeType === Node.TEXT_NODE && node.nodeValue !== null) {\n        const start = (node === rootNode ? (offset - 1) : (node.nodeValue.length - 1));\n        for (let i = start; i >= 0; --i) {\n          if (stopCharacters.indexOf(node.nodeValue[i]) !== -1) {\n            startNode = node;\n            startOffset = i + 1;\n            break;\n          }\n        }\n      }\n\n      if (startNode) {\n        break;\n      }\n\n      node = node.traversePreviousNode(stayWithinNode);\n    }\n\n    if (!startNode) {\n      startNode = stayWithinNode;\n      startOffset = 0;\n    }\n  } else {\n    startNode = rootNode;\n    startOffset = offset;\n  }\n\n  if (!direction || direction === 'forward' || direction === 'both') {\n    let node: (Node|null)|Node = rootNode;\n    while (node) {\n      if (node === stayWithinNode) {\n        if (!endNode) {\n          endNode = stayWithinNode;\n        }\n        break;\n      }\n\n      if (node.nodeType === Node.TEXT_NODE && node.nodeValue !== null) {\n        const start = (node === rootNode ? offset : 0);\n        for (let i = start; i < node.nodeValue.length; ++i) {\n          if (stopCharacters.indexOf(node.nodeValue[i]) !== -1) {\n            endNode = node;\n            endOffset = i;\n            break;\n          }\n        }\n      }\n\n      if (endNode) {\n        break;\n      }\n\n      node = node.traverseNextNode(stayWithinNode);\n    }\n\n    if (!endNode) {\n      endNode = stayWithinNode;\n      endOffset = stayWithinNode.nodeType === Node.TEXT_NODE ? stayWithinNode.nodeValue?.length || 0 :\n                                                               stayWithinNode.childNodes.length;\n    }\n  } else {\n    endNode = rootNode;\n    endOffset = offset;\n  }\n\n  if (!rootNode.ownerDocument) {\n    throw new Error('No `ownerDocument` found for rootNode');\n  }\n  const result = rootNode.ownerDocument.createRange();\n  result.setStart(startNode, startOffset);\n  result.setEnd(endNode, endOffset);\n\n  return result;\n}\n"],
  "mappings": "AASO,kCAA2B,KAA6B;AAC7D,MAAI,gBAA8B,IAAI;AACtC,SAAO,iBAAiB,cAAc,cAAc,cAAc,WAAW,eAAe;AAC1F,oBAAgB,cAAc,WAAW;AAAA;AAE3C,SAAO;AAAA;AAGF,8CAAuC,MAAuB;AACnE,MAAI,aAAa,KAAK;AACtB,SAAO,YAAY;AACjB,QAAI,sBAAsB,YAAY;AACpC,aAAO;AAAA;AAET,iBAAa,WAAW;AAAA;AAE1B,SAAO;AAAA;AAGF,4BACH,UAAgB,QAAgB,gBAAwB,gBAAsB,WAA2B;AAC3G,MAAI;AACJ,MAAI,cAAc;AAClB,MAAI;AACJ,MAAI,YAAY;AAEhB,MAAI,CAAC,gBAAgB;AACnB,qBAAiB;AAAA;AAGnB,MAAI,CAAC,aAAa,cAAc,cAAc,cAAc,QAAQ;AAClE,QAAI,OAAkB;AACtB,WAAO,MAAM;AACX,UAAI,SAAS,gBAAgB;AAC3B,YAAI,CAAC,WAAW;AACd,sBAAY;AAAA;AAEd;AAAA;AAGF,UAAI,KAAK,aAAa,KAAK,aAAa,KAAK,cAAc,MAAM;AAC/D,cAAM,QAAS,SAAS,WAAY,SAAS,IAAM,KAAK,UAAU,SAAS;AAC3E,iBAAS,IAAI,OAAO,KAAK,GAAG,EAAE,GAAG;AAC/B,cAAI,eAAe,QAAQ,KAAK,UAAU,QAAQ,IAAI;AACpD,wBAAY;AACZ,0BAAc,IAAI;AAClB;AAAA;AAAA;AAAA;AAKN,UAAI,WAAW;AACb;AAAA;AAGF,aAAO,KAAK,qBAAqB;AAAA;AAGnC,QAAI,CAAC,WAAW;AACd,kBAAY;AACZ,oBAAc;AAAA;AAAA,SAEX;AACL,gBAAY;AACZ,kBAAc;AAAA;AAGhB,MAAI,CAAC,aAAa,cAAc,aAAa,cAAc,QAAQ;AACjE,QAAI,OAAyB;AAC7B,WAAO,MAAM;AACX,UAAI,SAAS,gBAAgB;AAC3B,YAAI,CAAC,SAAS;AACZ,oBAAU;AAAA;AAEZ;AAAA;AAGF,UAAI,KAAK,aAAa,KAAK,aAAa,KAAK,cAAc,MAAM;AAC/D,cAAM,QAAS,SAAS,WAAW,SAAS;AAC5C,iBAAS,IAAI,OAAO,IAAI,KAAK,UAAU,QAAQ,EAAE,GAAG;AAClD,cAAI,eAAe,QAAQ,KAAK,UAAU,QAAQ,IAAI;AACpD,sBAAU;AACV,wBAAY;AACZ;AAAA;AAAA;AAAA;AAKN,UAAI,SAAS;AACX;AAAA;AAGF,aAAO,KAAK,iBAAiB;AAAA;AAG/B,QAAI,CAAC,SAAS;AACZ,gBAAU;AACV,kBAAY,eAAe,aAAa,KAAK,YAAY,eAAe,WAAW,UAAU,IACpC,eAAe,WAAW;AAAA;AAAA,SAEhF;AACL,cAAU;AACV,gBAAY;AAAA;AAGd,MAAI,CAAC,SAAS,eAAe;AAC3B,UAAM,IAAI,MAAM;AAAA;AAElB,QAAM,SAAS,SAAS,cAAc;AACtC,SAAO,SAAS,WAAW;AAC3B,SAAO,OAAO,SAAS;AAEvB,SAAO;AAAA;",
  "names": []
}
