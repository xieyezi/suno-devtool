{
  "version": 3,
  "sources": ["../../../../../../front_end/core/sdk/SourceMapManager.ts"],
  "sourcesContent": ["// Copyright 2017 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../common/common.js';\nimport * as Platform from '../platform/platform.js';\n\nimport {type FrameAssociated} from './FrameAssociated.js';\n\nimport {Type, type Target} from './Target.js';\nimport {Events as TargetManagerEvents, TargetManager} from './TargetManager.js';\n\nimport {TextSourceMap, type SourceMap} from './SourceMap.js';\n\nexport class SourceMapManager<T extends FrameAssociated> extends Common.ObjectWrapper.ObjectWrapper<EventTypes<T>> {\n  readonly #target: Target;\n  #isEnabled: boolean;\n  readonly #clientData: Map<T, ClientData>;\n  readonly #sourceMaps: Map<SourceMap, T>;\n\n  constructor(target: Target) {\n    super();\n\n    this.#target = target;\n    this.#isEnabled = true;\n    this.#clientData = new Map();\n    this.#sourceMaps = new Map();\n\n    TargetManager.instance().addEventListener(TargetManagerEvents.InspectedURLChanged, this.inspectedURLChanged, this);\n  }\n\n  setEnabled(isEnabled: boolean): void {\n    if (isEnabled === this.#isEnabled) {\n      return;\n    }\n    this.#isEnabled = isEnabled;\n\n    // We need this copy, because `this.#clientData` is getting modified\n    // in the loop body and trying to iterate over it at the same time\n    // leads to an infinite loop.\n    const clientData = [...this.#clientData.entries()];\n    for (const [client, {relativeSourceURL, relativeSourceMapURL}] of clientData) {\n      this.detachSourceMap(client);\n      this.attachSourceMap(client, relativeSourceURL, relativeSourceMapURL);\n    }\n  }\n\n  private static getBaseUrl(target: Target|null): Platform.DevToolsPath.UrlString {\n    while (target && target.type() !== Type.Frame) {\n      target = target.parentTarget();\n    }\n    return target?.inspectedURL() ?? Platform.DevToolsPath.EmptyUrlString;\n  }\n\n  static resolveRelativeSourceURL(target: Target|null, url: Platform.DevToolsPath.UrlString):\n      Platform.DevToolsPath.UrlString {\n    url = Common.ParsedURL.ParsedURL.completeURL(SourceMapManager.getBaseUrl(target), url) ?? url;\n    return url;\n  }\n\n  private inspectedURLChanged(event: Common.EventTarget.EventTargetEvent<Target>): void {\n    if (event.data !== this.#target) {\n      return;\n    }\n\n    // We need this copy, because `this.#clientData` is getting modified\n    // in the loop body and trying to iterate over it at the same time\n    // leads to an infinite loop.\n    const clientData = [...this.#clientData.entries()];\n    for (const [client, {relativeSourceURL, relativeSourceMapURL}] of clientData) {\n      this.detachSourceMap(client);\n      this.attachSourceMap(client, relativeSourceURL, relativeSourceMapURL);\n    }\n  }\n\n  sourceMapForClient(client: T): SourceMap|undefined {\n    return this.#clientData.get(client)?.sourceMap;\n  }\n\n  // This method actively awaits the source map, if still loading.\n  sourceMapForClientPromise(client: T): Promise<SourceMap|undefined> {\n    const clientData = this.#clientData.get(client);\n    if (!clientData) {\n      return Promise.resolve(undefined);\n    }\n\n    return clientData.sourceMapPromise;\n  }\n\n  clientForSourceMap(sourceMap: SourceMap): T|undefined {\n    return this.#sourceMaps.get(sourceMap);\n  }\n\n  // TODO(bmeurer): We are lying about the type of |relativeSourceURL| here.\n  attachSourceMap(\n      client: T, relativeSourceURL: Platform.DevToolsPath.UrlString, relativeSourceMapURL: string|undefined): void {\n    if (this.#clientData.has(client)) {\n      throw new Error('SourceMap is already attached or being attached to client');\n    }\n    if (!relativeSourceMapURL) {\n      return;\n    }\n\n    const clientData: ClientData = {\n      relativeSourceURL,\n      relativeSourceMapURL,\n      sourceMap: undefined,\n      sourceMapPromise: Promise.resolve(undefined),\n    };\n    if (this.#isEnabled) {\n      // The `// #sourceURL=foo` can be a random string, but is generally an absolute path.\n      // Complete it to inspected page url for relative links.\n      const sourceURL = SourceMapManager.resolveRelativeSourceURL(this.#target, relativeSourceURL);\n      const sourceMapURL = Common.ParsedURL.ParsedURL.completeURL(sourceURL, relativeSourceMapURL);\n      if (sourceMapURL) {\n        this.dispatchEventToListeners(Events.SourceMapWillAttach, {client});\n\n        const initiator = client.createPageResourceLoadInitiator();\n        clientData.sourceMapPromise =\n            TextSourceMap.load(sourceMapURL, sourceURL, initiator)\n                .then(\n                    sourceMap => {\n                      if (this.#clientData.get(client) === clientData) {\n                        clientData.sourceMap = sourceMap;\n                        this.#sourceMaps.set(sourceMap, client);\n                        this.dispatchEventToListeners(Events.SourceMapAttached, {client, sourceMap});\n                      }\n                      return sourceMap;\n                    },\n                    error => {\n                      Common.Console.Console.instance().warn(`DevTools failed to load source map: ${error.message}`);\n                      if (this.#clientData.get(client) === clientData) {\n                        this.dispatchEventToListeners(Events.SourceMapFailedToAttach, {client});\n                      }\n                      return undefined;\n                    });\n      }\n    }\n    this.#clientData.set(client, clientData);\n  }\n\n  detachSourceMap(client: T): void {\n    const clientData = this.#clientData.get(client);\n    if (!clientData) {\n      return;\n    }\n    this.#clientData.delete(client);\n    const {sourceMap} = clientData;\n    if (sourceMap) {\n      this.#sourceMaps.delete(sourceMap);\n      this.dispatchEventToListeners(Events.SourceMapDetached, {client, sourceMap});\n    } else {\n      this.dispatchEventToListeners(Events.SourceMapFailedToAttach, {client});\n    }\n  }\n\n  dispose(): void {\n    TargetManager.instance().removeEventListener(\n        TargetManagerEvents.InspectedURLChanged, this.inspectedURLChanged, this);\n  }\n}\n\ntype ClientData = {\n  relativeSourceURL: Platform.DevToolsPath.UrlString,\n  // Stores the raw sourceMappingURL as provided by V8. These are not guaranteed to\n  // be valid URLs and will be checked and resolved once `attachSourceMap` is called.\n  relativeSourceMapURL: string,\n  sourceMap: SourceMap|undefined,\n  sourceMapPromise: Promise<SourceMap|undefined>,\n};\n\n// TODO(crbug.com/1167717): Make this a const enum again\n// eslint-disable-next-line rulesdir/const_enum\nexport enum Events {\n  SourceMapWillAttach = 'SourceMapWillAttach',\n  SourceMapFailedToAttach = 'SourceMapFailedToAttach',\n  SourceMapAttached = 'SourceMapAttached',\n  SourceMapDetached = 'SourceMapDetached',\n}\n\nexport type EventTypes<T extends FrameAssociated> = {\n  [Events.SourceMapWillAttach]: {client: T},\n  [Events.SourceMapFailedToAttach]: {client: T},\n  [Events.SourceMapAttached]: {client: T, sourceMap: SourceMap},\n  [Events.SourceMapDetached]: {client: T, sourceMap: SourceMap},\n};\n"],
  "mappings": "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",
  "names": []
}
