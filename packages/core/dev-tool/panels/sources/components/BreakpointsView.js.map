{
  "version": 3,
  "sources": ["../../../../../../../front_end/panels/sources/components/BreakpointsView.ts"],
  "sourcesContent": ["// Copyright (c) 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Host from '../../../core/host/host.js';\nimport * as i18n from '../../../core/i18n/i18n.js';\nimport * as Platform from '../../../core/platform/platform.js';\nimport {assertNotNullOrUndefined} from '../../../core/platform/platform.js';\nimport * as ComponentHelpers from '../../../ui/components/helpers/helpers.js';\nimport * as IconButton from '../../../ui/components/icon_button/icon_button.js';\nimport * as Coordinator from '../../../ui/components/render_coordinator/render_coordinator.js';\nimport * as UI from '../../../ui/legacy/legacy.js';\nimport * as LitHtml from '../../../ui/lit-html/lit-html.js';\n\nimport breakpointsViewStyles from './breakpointsView.css.js';\nimport {findNextNodeForKeyboardNavigation} from './BreakpointsViewUtils.js';\n\nconst UIStrings = {\n  /**\n   *@description Label for a checkbox to toggle pausing on uncaught exceptions in the breakpoint sidebar of the Sources panel. When the checkbox is checked, DevTools will pause if an uncaught exception is thrown at runtime.\n   */\n  pauseOnUncaughtExceptions: 'Pause on uncaught exceptions',\n  /**\n   *@description Label for a checkbox to toggling pausing on caught exceptions in the breakpoint sidebar of the Sources panel. When the checkbox is checked, DevTools will pause if an exception is thrown, but caught (handled) at runtime.\n   */\n  pauseOnCaughtExceptions: 'Pause on caught exceptions',\n  /**\n   *@description Text exposed to screen readers on checked items.\n   */\n  checked: 'checked',\n  /**\n   *@description Accessible text exposed to screen readers when the screen reader encounters an unchecked checkbox.\n   */\n  unchecked: 'unchecked',\n  /**\n   *@description Accessible text for a breakpoint collection with a combination of checked states.\n   */\n  indeterminate: 'mixed',\n  /**\n   *@description Accessibility label for hit breakpoints in the Sources panel.\n   *@example {checked} PH1\n   */\n  breakpointHit: '{PH1} breakpoint hit',\n  /**\n   *@description Tooltip text that shows when hovered over a remove button that appears next to a filename in the breakpoint sidebar of the sources panel. Also used in the context menu for breakpoint groups.\n   */\n  removeAllBreakpointsInFile: 'Remove all breakpoints in file',\n  /**\n   *@description Context menu item in the Breakpoints Sidebar Pane of the Sources panel that disables all breakpoints in a file.\n   */\n  disableAllBreakpointsInFile: 'Disable all breakpoints in file',\n  /**\n   *@description Context menu item in the Breakpoints Sidebar Pane of the Sources panel that enables all breakpoints in a file.\n   */\n  enableAllBreakpointsInFile: 'Enable all breakpoints in file',\n  /**\n   *@description Tooltip text that shows when hovered over an edit button that appears next to a breakpoint or conditional breakpoint in the breakpoint sidebar of the sources panel.\n   */\n  editCondition: 'Edit condition',\n  /**\n   *@description Tooltip text that shows when hovered over an edit button that appears next to a logpoint in the breakpoint sidebar of the sources panel.\n   */\n  editLogpoint: 'Edit logpoint',\n  /**\n   *@description Tooltip text that shows when hovered over a remove button that appears next to a breakpoint in the breakpoint sidebar of the sources panel. Also used in the context menu for breakpoint items.\n   */\n  removeBreakpoint: 'Remove breakpoint',\n  /**\n   *@description Text to remove all breakpoints\n   */\n  removeAllBreakpoints: 'Remove all breakpoints',\n  /**\n   *@description Text in Breakpoints Sidebar Pane of the Sources panel\n   */\n  removeOtherBreakpoints: 'Remove other breakpoints',\n  /**\n   *@description Context menu item that reveals the source code location of a breakpoint in the Sources panel.\n   */\n  revealLocation: 'Reveal location',\n  /**\n   *@description Tooltip text that shows when hovered over a piece of code of a breakpoint in the breakpoint sidebar of the sources panel. It shows the condition, on which the breakpoint will stop.\n   *@example {x < 3} PH1\n   */\n  conditionCode: 'Condition: {PH1}',\n  /**\n   *@description Tooltip text that shows when hovered over a piece of code of a breakpoint in the breakpoint sidebar of the sources panel. It shows what is going to be printed in the console, if execution hits this breakpoint.\n   *@example {'hello'} PH1\n   */\n  logpointCode: 'Logpoint: {PH1}',\n};\nconst str_ = i18n.i18n.registerUIStrings('panels/sources/components/BreakpointsView.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\nconst coordinator = Coordinator.RenderCoordinator.RenderCoordinator.instance();\n\nconst MAX_SNIPPET_LENGTH = 200;\n\nexport interface BreakpointsViewData {\n  breakpointsActive: boolean;\n  pauseOnUncaughtExceptions: boolean;\n  pauseOnCaughtExceptions: boolean;\n  // TODO(crbug.com/1382762): Remove special casing with dependent toggles as soon as Node LTS caught up on independent pause of exception toggles.\n  independentPauseToggles: boolean;\n  groups: BreakpointGroup[];\n}\n\nexport interface BreakpointGroup {\n  name: string;\n  url: Platform.DevToolsPath.UrlString;\n  editable: boolean;\n  expanded: boolean;\n  breakpointItems: BreakpointItem[];\n}\n\nexport interface BreakpointItem {\n  id: string;\n  location: string;\n  codeSnippet: string;\n  isHit: boolean;\n  status: BreakpointStatus;\n  type: BreakpointType;\n  hoverText?: string;\n}\n\nexport const enum BreakpointStatus {\n  ENABLED = 'ENABLED',\n  DISABLED = 'DISABLED',\n  INDETERMINATE = 'INDETERMINATE',\n}\n\nexport const enum BreakpointType {\n  LOGPOINT = 'LOGPOINT',\n  CONDITIONAL_BREAKPOINT = 'CONDITIONAL_BREAKPOINT',\n  REGULAR_BREAKPOINT = 'REGULAR_BREAKPOINT',\n}\n\nexport class CheckboxToggledEvent extends Event {\n  static readonly eventName = 'checkboxtoggled';\n  data: {breakpointItem: BreakpointItem, checked: boolean};\n\n  constructor(breakpointItem: BreakpointItem, checked: boolean) {\n    super(CheckboxToggledEvent.eventName);\n    this.data = {breakpointItem: breakpointItem, checked};\n  }\n}\n\nexport class PauseOnUncaughtExceptionsStateChangedEvent extends Event {\n  static readonly eventName = 'pauseonuncaughtexceptionsstatechanged';\n  data: {checked: boolean};\n\n  constructor(checked: boolean) {\n    super(PauseOnUncaughtExceptionsStateChangedEvent.eventName);\n    this.data = {checked};\n  }\n}\n\nexport class PauseOnCaughtExceptionsStateChangedEvent extends Event {\n  static readonly eventName = 'pauseoncaughtexceptionsstatechanged';\n  data: {checked: boolean};\n\n  constructor(checked: boolean) {\n    super(PauseOnCaughtExceptionsStateChangedEvent.eventName);\n    this.data = {checked};\n  }\n}\n\nexport class ExpandedStateChangedEvent extends Event {\n  static readonly eventName = 'expandedstatechanged';\n  data: {url: Platform.DevToolsPath.UrlString, expanded: boolean};\n\n  constructor(url: Platform.DevToolsPath.UrlString, expanded: boolean) {\n    super(ExpandedStateChangedEvent.eventName);\n    this.data = {url, expanded};\n  }\n}\n\nexport class BreakpointSelectedEvent extends Event {\n  static readonly eventName = 'breakpointselected';\n  data: {breakpointItem: BreakpointItem};\n\n  constructor(breakpointItem: BreakpointItem) {\n    super(BreakpointSelectedEvent.eventName);\n    this.data = {breakpointItem: breakpointItem};\n  }\n}\n\nexport class BreakpointEditedEvent extends Event {\n  static readonly eventName = 'breakpointedited';\n  data: {breakpointItem: BreakpointItem};\n\n  constructor(breakpointItem: BreakpointItem) {\n    super(BreakpointEditedEvent.eventName);\n    this.data = {breakpointItem};\n  }\n}\n\nexport class BreakpointsRemovedEvent extends Event {\n  static readonly eventName = 'breakpointsremoved';\n  data: {breakpointItems: BreakpointItem[]};\n\n  constructor(breakpointItems: BreakpointItem[]) {\n    super(BreakpointsRemovedEvent.eventName);\n    this.data = {breakpointItems};\n  }\n}\n\nexport class BreakpointsView extends HTMLElement {\n  static readonly litTagName = LitHtml.literal`devtools-breakpoint-view`;\n  readonly #shadow = this.attachShadow({mode: 'open'});\n\n  #pauseOnUncaughtExceptions: boolean = false;\n  #pauseOnCaughtExceptions: boolean = false;\n\n  // TODO(crbug.com/1382762): Remove special casing with dependent toggles as soon as Node LTS caught up on independent pause of exception toggles.\n  #independentPauseToggles: boolean = false;\n\n  #breakpointsActive: boolean = true;\n  #breakpointGroups: BreakpointGroup[] = [];\n  #scheduledRender = false;\n  #enqueuedRender = false;\n\n  set data(data: BreakpointsViewData) {\n    this.#pauseOnUncaughtExceptions = data.pauseOnUncaughtExceptions;\n    this.#pauseOnCaughtExceptions = data.pauseOnCaughtExceptions;\n    this.#independentPauseToggles = data.independentPauseToggles;\n    this.#breakpointsActive = data.breakpointsActive;\n    this.#breakpointGroups = data.groups;\n\n    void this.#render();\n  }\n\n  connectedCallback(): void {\n    this.#shadow.adoptedStyleSheets = [breakpointsViewStyles];\n  }\n\n  async #render(): Promise<void> {\n    if (this.#scheduledRender) {\n      // If we are already rendering, don't render again immediately, but\n      // enqueue it to be run after we're done on our current render.\n      this.#enqueuedRender = true;\n      return;\n    }\n\n    this.#scheduledRender = true;\n    await coordinator.write('BreakpointsView render', () => {\n      const clickHandler = async(event: Event): Promise<void> => {\n        const currentTarget = event.currentTarget as HTMLElement;\n        await this.#setSelected(currentTarget);\n        event.consume();\n      };\n\n      const pauseOnCaughtIsChecked =\n          (this.#independentPauseToggles || this.#pauseOnUncaughtExceptions) && this.#pauseOnCaughtExceptions;\n      const pauseOnCaughtExceptionIsDisabled = !this.#independentPauseToggles && !this.#pauseOnUncaughtExceptions;\n      // clang-format off\n      const out = LitHtml.html`\n        <div class='pause-on-uncaught-exceptions'\n            tabindex='0'\n            @click=${clickHandler}\n            @keydown=${this.#keyDownHandler}\n            data-first-pause>\n          <label class='checkbox-label'>\n            <input type='checkbox' tabindex=-1 ?checked=${this.#pauseOnUncaughtExceptions} @change=${this.#onPauseOnUncaughtExceptionsStateChanged.bind(this)}>\n            <span>${i18nString(UIStrings.pauseOnUncaughtExceptions)}</span>\n          </label>\n        </div>\n        <div class='pause-on-caught-exceptions'\n              tabindex='-1'\n              @click=${clickHandler}\n              @keydown=${this.#keyDownHandler}\n              data-last-pause>\n            <label class='checkbox-label'>\n              <input data-pause-on-caught-checkbox type='checkbox' tabindex=-1 ?checked=${pauseOnCaughtIsChecked} ?disabled=${pauseOnCaughtExceptionIsDisabled} @change=${this.#onPauseOnCaughtExceptionsStateChanged.bind(this)}>\n              <span>${i18nString(UIStrings.pauseOnCaughtExceptions)}</span>\n            </label>\n        </div>\n        <div role=tree>\n          ${LitHtml.Directives.repeat(\n            this.#breakpointGroups,\n            group => group.url,\n            (group, groupIndex) => LitHtml.html`${this.#renderBreakpointGroup(group, groupIndex)}`)}\n        </div>`;\n      // clang-format on\n      LitHtml.render(out, this.#shadow, {host: this});\n    });\n\n    // If no element is tabbable, set the pause-on-exceptions to be tabbable. This can happen\n    // if the previously focused element was removed.\n    await coordinator.write('make pause-on-exceptions focusable', () => {\n      if (this.#shadow.querySelector('[tabindex=\"0\"]') === null) {\n        const element = this.#shadow.querySelector<HTMLElement>('[data-first-pause]');\n        element?.setAttribute('tabindex', '0');\n      }\n    });\n\n    this.#scheduledRender = false;\n\n    // If render() was called when we were already mid-render, let's re-render\n    // to ensure we're not rendering any stale UI.\n    if (this.#enqueuedRender) {\n      this.#enqueuedRender = false;\n      return this.#render();\n    }\n  }\n\n  async #keyDownHandler(event: KeyboardEvent): Promise<void> {\n    if (!event.target || !(event.target instanceof HTMLElement)) {\n      return;\n    }\n\n    if (event.key === 'Home' || event.key === 'End') {\n      event.consume(true);\n      return this.#handleHomeOrEndKey(event.key);\n    }\n    if (Platform.KeyboardUtilities.keyIsArrowKey(event.key)) {\n      event.consume(true);\n      return this.#handleArrowKey(event.key, event.target);\n    }\n    return;\n  }\n\n  async #setSelected(element: HTMLElement|null): Promise<void> {\n    if (!element) {\n      return;\n    }\n    void coordinator.write('focus on selected element', () => {\n      const prevSelected = this.#shadow.querySelector('[tabindex=\"0\"]');\n      prevSelected?.setAttribute('tabindex', '-1');\n      element.setAttribute('tabindex', '0');\n      element.focus();\n    });\n  }\n\n  async #handleArrowKey(key: Platform.KeyboardUtilities.ArrowKey, target: HTMLElement): Promise<void> {\n    const setGroupExpandedState = (detailsElement: HTMLDetailsElement, expanded: boolean): Promise<void> => {\n      if (expanded) {\n        return coordinator.write('expand', () => {\n          detailsElement.setAttribute('open', '');\n        });\n      }\n      return coordinator.write('expand', () => {\n        detailsElement.removeAttribute('open');\n      });\n    };\n    const nextNode = await findNextNodeForKeyboardNavigation(target, key, setGroupExpandedState);\n    return this.#setSelected(nextNode);\n  }\n\n  async #handleHomeOrEndKey(key: 'Home'|'End'): Promise<void> {\n    if (key === 'Home') {\n      const pauseOnExceptionsNode = this.#shadow.querySelector<HTMLElement>('[data-first-pause]');\n      return this.#setSelected(pauseOnExceptionsNode);\n    }\n    if (key === 'End') {\n      const numGroups = this.#breakpointGroups.length;\n      if (numGroups === 0) {\n        const lastPauseOnExceptionsNode = this.#shadow.querySelector<HTMLElement>('[data-last-pause]');\n        return this.#setSelected(lastPauseOnExceptionsNode);\n      }\n      const lastGroupIndex = numGroups - 1;\n      const lastGroup = this.#breakpointGroups[lastGroupIndex];\n\n      if (lastGroup.expanded) {\n        const lastBreakpointItem =\n            this.#shadow.querySelector<HTMLElement>('[data-last-group] > [data-last-breakpoint]');\n        return this.#setSelected(lastBreakpointItem);\n      }\n      const lastGroupSummaryElement = this.#shadow.querySelector<HTMLElement>('[data-last-group] > summary');\n      return this.#setSelected(lastGroupSummaryElement);\n    }\n    return;\n  }\n\n  #renderEditBreakpointButton(breakpointItem: BreakpointItem): LitHtml.TemplateResult {\n    const clickHandler = (event: Event): void => {\n      Host.userMetrics.breakpointEditDialogRevealedFrom(\n          Host.UserMetrics.BreakpointEditDialogRevealedFrom.BreakpointSidebarEditButton);\n      this.dispatchEvent(new BreakpointEditedEvent(breakpointItem));\n      event.consume();\n    };\n    const title = breakpointItem.type === BreakpointType.LOGPOINT ? i18nString(UIStrings.editLogpoint) :\n                                                                    i18nString(UIStrings.editCondition);\n    // clang-format off\n    return LitHtml.html`\n    <button data-edit-breakpoint @click=${clickHandler} title=${title}>\n    <${IconButton.Icon.Icon.litTagName} .data=${{\n        iconName: 'edit-icon',\n        width: '14px',\n        color: 'var(--color-text-secondary)',\n      } as IconButton.Icon.IconData}\n      }>\n      </${IconButton.Icon.Icon.litTagName}>\n    </button>\n      `;\n    // clang-format on\n  }\n\n  #renderRemoveBreakpointButton(breakpointItems: BreakpointItem[], tooltipText: string): LitHtml.TemplateResult {\n    const clickHandler = (event: Event): void => {\n      Host.userMetrics.actionTaken(Host.UserMetrics.Action.BreakpointRemovedFromRemoveButton);\n      this.dispatchEvent(new BreakpointsRemovedEvent(breakpointItems));\n      event.consume();\n    };\n    // clang-format off\n    return LitHtml.html`\n    <button data-remove-breakpoint @click=${clickHandler} title=${tooltipText}>\n    <${IconButton.Icon.Icon.litTagName} .data=${{\n        iconName: 'close-icon',\n        width: '10px',\n        color: 'var(--color-text-secondary)',\n      } as IconButton.Icon.IconData}\n      }>\n      </${IconButton.Icon.Icon.litTagName}>\n    </button>\n      `;\n    // clang-format on\n  }\n\n  #onBreakpointGroupContextMenu(event: Event, breakpointGroup: BreakpointGroup): void {\n    const {breakpointItems} = breakpointGroup;\n    const menu = new UI.ContextMenu.ContextMenu(event);\n\n    menu.defaultSection().appendItem(i18nString(UIStrings.removeAllBreakpointsInFile), () => {\n      this.dispatchEvent(new BreakpointsRemovedEvent(breakpointItems));\n    });\n    const notDisabledItems =\n        breakpointItems.filter(breakpointItem => breakpointItem.status !== BreakpointStatus.DISABLED);\n    menu.defaultSection().appendItem(i18nString(UIStrings.disableAllBreakpointsInFile), () => {\n      for (const breakpointItem of notDisabledItems) {\n        this.dispatchEvent(new CheckboxToggledEvent(breakpointItem, false));\n      }\n    }, notDisabledItems.length === 0);\n    const notEnabledItems =\n        breakpointItems.filter(breakpointItem => breakpointItem.status !== BreakpointStatus.ENABLED);\n    menu.defaultSection().appendItem(i18nString(UIStrings.enableAllBreakpointsInFile), () => {\n      for (const breakpointItem of notEnabledItems) {\n        this.dispatchEvent(new CheckboxToggledEvent(breakpointItem, true));\n      }\n    }, notEnabledItems.length === 0);\n    menu.defaultSection().appendItem(i18nString(UIStrings.removeAllBreakpoints), () => {\n      const breakpointItems = this.#breakpointGroups.map(({breakpointItems}) => breakpointItems).flat();\n      this.dispatchEvent(new BreakpointsRemovedEvent(breakpointItems));\n    });\n    const otherGroups = this.#breakpointGroups.filter(group => group !== breakpointGroup);\n    menu.defaultSection().appendItem(i18nString(UIStrings.removeOtherBreakpoints), () => {\n      const breakpointItems = otherGroups.map(({breakpointItems}) => breakpointItems).flat();\n      this.dispatchEvent(new BreakpointsRemovedEvent(breakpointItems));\n    }, otherGroups.length === 0);\n\n    void menu.show();\n  }\n\n  #renderBreakpointGroup(group: BreakpointGroup, groupIndex: number): LitHtml.TemplateResult {\n    const contextmenuHandler = (event: Event): void => {\n      this.#onBreakpointGroupContextMenu(event, group);\n      event.consume();\n    };\n    const toggleHandler = (event: Event): void => {\n      const htmlDetails = event.target as HTMLDetailsElement;\n      group.expanded = htmlDetails.open;\n      this.dispatchEvent(new ExpandedStateChangedEvent(group.url, group.expanded));\n    };\n    const clickHandler = async(event: Event): Promise<void> => {\n      const selected = event.currentTarget as HTMLElement;\n      await this.#setSelected(selected);\n      // Record the metric for expanding/collapsing in the click handler,\n      // as we only then get the number of expand/collapse actions that were\n      // initiated by the user.\n      Host.userMetrics.actionTaken(Host.UserMetrics.Action.BreakpointGroupExpandedStateChanged);\n      event.consume();\n    };\n    const classMap = {\n      active: this.#breakpointsActive,\n    };\n    // clang-format off\n    return LitHtml.html`\n      <details class=${LitHtml.Directives.classMap(classMap)}\n               ?data-first-group=${groupIndex === 0}\n               ?data-last-group=${groupIndex === this.#breakpointGroups.length - 1}\n               role=group\n               aria-label='${group.name}'\n               aria-description='${group.url}'\n               ?open=${LitHtml.Directives.live(group.expanded)}\n               @toggle=${toggleHandler}>\n          <summary @contextmenu=${contextmenuHandler}\n                   tabindex='-1'\n                   @keydown=${this.#keyDownHandler}\n                   @click=${clickHandler}>\n          <span class='group-header' aria-hidden=true>${this.#renderFileIcon()}<span class='group-header-title' title='${group.url}'>${group.name}</span></span>\n          <span class='group-hover-actions'>\n            ${this.#renderRemoveBreakpointButton(group.breakpointItems, i18nString(UIStrings.removeAllBreakpointsInFile))}\n          </span>\n        </summary>\n        ${LitHtml.Directives.repeat(\n          group.breakpointItems,\n          item => item.id,\n          (item, breakpointItemIndex) => this.#renderBreakpointEntry(item, group.editable, groupIndex, breakpointItemIndex))}\n      </div>\n      `;\n    // clang-format on\n  }\n\n  #renderFileIcon(): LitHtml.TemplateResult {\n    return LitHtml.html`\n      <${IconButton.Icon.Icon.litTagName} .data=${\n        {iconName: 'ic_file_script', color: 'var(--color-ic-file-script)', width: '16px', height: '16px'} as\n        IconButton.Icon.IconWithName}></${IconButton.Icon.Icon.litTagName}>\n    `;\n  }\n\n  #onBreakpointEntryContextMenu(event: Event, breakpointItem: BreakpointItem, editable: boolean): void {\n    const menu = new UI.ContextMenu.ContextMenu(event);\n    const editBreakpointText = breakpointItem.type === BreakpointType.LOGPOINT ? i18nString(UIStrings.editLogpoint) :\n                                                                                 i18nString(UIStrings.editCondition);\n\n    menu.defaultSection().appendItem(i18nString(UIStrings.removeBreakpoint), () => {\n      this.dispatchEvent(new BreakpointsRemovedEvent([breakpointItem]));\n    });\n    menu.defaultSection().appendItem(editBreakpointText, () => {\n      Host.userMetrics.breakpointEditDialogRevealedFrom(\n          Host.UserMetrics.BreakpointEditDialogRevealedFrom.BreakpointSidebarContextMenu);\n      this.dispatchEvent(new BreakpointEditedEvent(breakpointItem));\n    }, !editable);\n    menu.defaultSection().appendItem(i18nString(UIStrings.revealLocation), () => {\n      this.dispatchEvent(new BreakpointSelectedEvent(breakpointItem));\n    });\n    menu.defaultSection().appendItem(i18nString(UIStrings.removeAllBreakpoints), () => {\n      const breakpointItems = this.#breakpointGroups.map(({breakpointItems}) => breakpointItems).flat();\n      this.dispatchEvent(new BreakpointsRemovedEvent(breakpointItems));\n    });\n    const otherItems = this.#breakpointGroups.map(({breakpointItems}) => breakpointItems)\n                           .flat()\n                           .filter(item => item !== breakpointItem);\n    menu.defaultSection().appendItem(i18nString(UIStrings.removeOtherBreakpoints), () => {\n      this.dispatchEvent(new BreakpointsRemovedEvent(otherItems));\n    }, otherItems.length === 0);\n\n    void menu.show();\n  }\n\n  #renderBreakpointEntry(\n      breakpointItem: BreakpointItem, editable: boolean, groupIndex: number,\n      breakpointItemIndex: number): LitHtml.TemplateResult {\n    const codeSnippetClickHandler = (event: Event): void => {\n      this.dispatchEvent(new BreakpointSelectedEvent(breakpointItem));\n      event.consume();\n    };\n    const breakpointItemClickHandler = async(event: Event): Promise<void> => {\n      const target = event.currentTarget as HTMLDivElement;\n      await this.#setSelected(target);\n      event.consume();\n    };\n    const contextmenuHandler = (event: Event): void => {\n      this.#onBreakpointEntryContextMenu(event, breakpointItem, editable);\n      event.consume();\n    };\n    const classMap = {\n      'breakpoint-item': true,\n      'hit': breakpointItem.isHit,\n      'conditional-breakpoint': breakpointItem.type === BreakpointType.CONDITIONAL_BREAKPOINT,\n      'logpoint': breakpointItem.type === BreakpointType.LOGPOINT,\n    };\n    const breakpointItemDescription = this.#getBreakpointItemDescription(breakpointItem);\n    const codeSnippet = Platform.StringUtilities.trimEndWithMaxLength(breakpointItem.codeSnippet, MAX_SNIPPET_LENGTH);\n    const codeSnippetTooltip = this.#getCodeSnippetTooltip(breakpointItem.type, breakpointItem.hoverText);\n    const itemsInGroup = this.#breakpointGroups[groupIndex].breakpointItems;\n\n    // clang-format off\n    return LitHtml.html`\n    <div class=${LitHtml.Directives.classMap(classMap)}\n         ?data-first-breakpoint=${breakpointItemIndex === 0}\n         ?data-last-breakpoint=${breakpointItemIndex === itemsInGroup.length - 1}\n         aria-label=${breakpointItemDescription}\n         role=treeitem\n         tabindex='-1'\n         @contextmenu=${contextmenuHandler}\n         @click=${breakpointItemClickHandler}\n         @keydown=${this.#keyDownHandler}>\n      <label class='checkbox-label'>\n        <span class='type-indicator'></span>\n        <input type='checkbox'\n              aria-label=${breakpointItem.location}\n              ?indeterminate=${breakpointItem.status === BreakpointStatus.INDETERMINATE}\n              ?checked=${breakpointItem.status === BreakpointStatus.ENABLED}\n              @change=${(e: Event): void => this.#onCheckboxToggled(e, breakpointItem)}\n              tabindex=-1>\n      </label>\n      <span class='code-snippet' @click=${codeSnippetClickHandler} title=${codeSnippetTooltip}>${codeSnippet}</span>\n      <span class='breakpoint-item-location-or-actions'>\n        ${editable ? this.#renderEditBreakpointButton(breakpointItem) : LitHtml.nothing}\n        ${this.#renderRemoveBreakpointButton([breakpointItem], i18nString(UIStrings.removeBreakpoint))}\n        <span class='location'>${breakpointItem.location}</span>\n      </span>\n    </div>\n    `;\n    // clang-format on\n  }\n\n  #getCodeSnippetTooltip(type: BreakpointType, hoverText?: string): string|undefined {\n    switch (type) {\n      case BreakpointType.REGULAR_BREAKPOINT:\n        return undefined;\n      case BreakpointType.CONDITIONAL_BREAKPOINT:\n        assertNotNullOrUndefined(hoverText);\n        return i18nString(UIStrings.conditionCode, {PH1: hoverText});\n      case BreakpointType.LOGPOINT:\n        assertNotNullOrUndefined(hoverText);\n        return i18nString(UIStrings.logpointCode, {PH1: hoverText});\n    }\n  }\n\n  #getBreakpointItemDescription(breakpointItem: BreakpointItem): Platform.UIString.LocalizedString {\n    let checkboxDescription;\n    switch (breakpointItem.status) {\n      case BreakpointStatus.ENABLED:\n        checkboxDescription = i18nString(UIStrings.checked);\n        break;\n      case BreakpointStatus.DISABLED:\n        checkboxDescription = i18nString(UIStrings.unchecked);\n        break;\n      case BreakpointStatus.INDETERMINATE:\n        checkboxDescription = i18nString(UIStrings.indeterminate);\n        break;\n    }\n    if (!breakpointItem.isHit) {\n      return checkboxDescription;\n    }\n    return i18nString(UIStrings.breakpointHit, {PH1: checkboxDescription});\n  }\n\n  #onCheckboxToggled(e: Event, item: BreakpointItem): void {\n    const element = e.target as HTMLInputElement;\n    this.dispatchEvent(new CheckboxToggledEvent(item, element.checked));\n  }\n\n  #onPauseOnCaughtExceptionsStateChanged(e: Event): void {\n    const {checked} = e.target as HTMLInputElement;\n    this.dispatchEvent(new PauseOnCaughtExceptionsStateChangedEvent(checked));\n  }\n\n  #onPauseOnUncaughtExceptionsStateChanged(e: Event): void {\n    const {checked} = e.target as HTMLInputElement;\n    if (!this.#independentPauseToggles) {\n      const pauseOnCaughtCheckbox = this.#shadow.querySelector<HTMLInputElement>('[data-pause-on-caught-checkbox]');\n      assertNotNullOrUndefined(pauseOnCaughtCheckbox);\n      if (!checked && pauseOnCaughtCheckbox.checked) {\n        // If we can only pause on caught excpetions if we pause on uncaught exceptions, make sure to\n        // uncheck the pause on caught exception checkbox.\n        pauseOnCaughtCheckbox.click();\n      }\n\n      void coordinator.write('update pause-on-uncaught-exception', () => {\n        // Disable/enable the pause on caught exception checkbox depending on whether\n        // or not we are pausing on uncaught exceptions.\n        if (checked) {\n          pauseOnCaughtCheckbox.disabled = false;\n        } else {\n          pauseOnCaughtCheckbox.disabled = true;\n        }\n      });\n    }\n    this.dispatchEvent(new PauseOnUncaughtExceptionsStateChangedEvent(checked));\n  }\n}\n\nComponentHelpers.CustomElements.defineComponent('devtools-breakpoint-view', BreakpointsView);\n\ndeclare global {\n  interface HTMLElementTagNameMap {\n    'devtools-breakpoint-view': BreakpointsView;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
