{
  "version": 3,
  "sources": ["../../../../../../front_end/panels/sources/BreakpointsSidebarPane.ts"],
  "sourcesContent": ["// Copyright (c) 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../core/common/common.js';\nimport * as Platform from '../../core/platform/platform.js';\nimport {assertNotNullOrUndefined} from '../../core/platform/platform.js';\nimport * as SDK from '../../core/sdk/sdk.js';\nimport * as Bindings from '../../models/bindings/bindings.js';\nimport * as TextUtils from '../../models/text_utils/text_utils.js';\nimport * as Workspace from '../../models/workspace/workspace.js';\nimport * as UI from '../../ui/legacy/legacy.js';\n\nimport {LogpointPrefix, LogpointSuffix} from './BreakpointEditDialog.js';\nimport * as SourcesComponents from './components/components.js';\n\nlet breakpointsSidebarPaneInstance: BreakpointsSidebarPane;\nlet breakpointsViewControllerInstance: BreakpointsSidebarController|null;\n\nexport class BreakpointsSidebarPane extends UI.ThrottledWidget.ThrottledWidget {\n  readonly #breakpointsView: SourcesComponents.BreakpointsView.BreakpointsView;\n  readonly #controller: BreakpointsSidebarController;\n\n  static instance(): BreakpointsSidebarPane {\n    if (!breakpointsSidebarPaneInstance) {\n      breakpointsSidebarPaneInstance = new BreakpointsSidebarPane();\n    }\n    return breakpointsSidebarPaneInstance;\n  }\n\n  constructor() {\n    super(true);\n    this.#controller = BreakpointsSidebarController.instance();\n    this.#breakpointsView = new SourcesComponents.BreakpointsView.BreakpointsView();\n    this.#breakpointsView.addEventListener(\n        SourcesComponents.BreakpointsView.CheckboxToggledEvent.eventName, (event: Event) => {\n          const {data: {breakpointItem, checked}} = event as SourcesComponents.BreakpointsView.CheckboxToggledEvent;\n          this.#controller.breakpointStateChanged(breakpointItem, checked);\n          event.consume();\n        });\n    this.#breakpointsView.addEventListener(\n        SourcesComponents.BreakpointsView.BreakpointSelectedEvent.eventName, (event: Event) => {\n          const {data: {breakpointItem}} = event as SourcesComponents.BreakpointsView.BreakpointSelectedEvent;\n          void this.#controller.jumpToSource(breakpointItem);\n          event.consume();\n        });\n    this.#breakpointsView.addEventListener(\n        SourcesComponents.BreakpointsView.BreakpointEditedEvent.eventName, (event: Event) => {\n          const {data: {breakpointItem}} = event as SourcesComponents.BreakpointsView.BreakpointEditedEvent;\n          void this.#controller.breakpointEdited(breakpointItem);\n          event.consume();\n        });\n    this.#breakpointsView.addEventListener(\n        SourcesComponents.BreakpointsView.BreakpointsRemovedEvent.eventName, (event: Event) => {\n          const {data: {breakpointItems}} = event as SourcesComponents.BreakpointsView.BreakpointsRemovedEvent;\n          void this.#controller.breakpointsRemoved(breakpointItems);\n          event.consume();\n        });\n    this.#breakpointsView.addEventListener(\n        SourcesComponents.BreakpointsView.ExpandedStateChangedEvent.eventName, (event: Event) => {\n          const {data: {url, expanded}} = event as SourcesComponents.BreakpointsView.ExpandedStateChangedEvent;\n          void this.#controller.expandedStateChanged(url, expanded);\n          event.consume();\n        });\n    this.#breakpointsView.addEventListener(\n        SourcesComponents.BreakpointsView.PauseOnUncaughtExceptionsStateChangedEvent.eventName, (event: Event) => {\n          const {data: {checked}} =\n              event as SourcesComponents.BreakpointsView.PauseOnUncaughtExceptionsStateChangedEvent;\n          this.#controller.setPauseOnUncaughtExceptions(checked);\n          event.consume();\n        });\n    this.#breakpointsView.addEventListener(\n        SourcesComponents.BreakpointsView.PauseOnCaughtExceptionsStateChangedEvent.eventName, (event: Event) => {\n          const {data: {checked}} = event as SourcesComponents.BreakpointsView.PauseOnCaughtExceptionsStateChangedEvent;\n          this.#controller.setPauseOnCaughtExceptions(checked);\n          event.consume();\n        });\n\n    this.contentElement.appendChild(this.#breakpointsView);\n    this.update();\n  }\n\n  doUpdate(): Promise<void> {\n    return this.#controller.update();\n  }\n\n  set data(data: SourcesComponents.BreakpointsView.BreakpointsViewData) {\n    this.#breakpointsView.data = data;\n  }\n}\n\nexport class BreakpointsSidebarController implements UI.ContextFlavorListener.ContextFlavorListener {\n  readonly #breakpointManager: Bindings.BreakpointManager.BreakpointManager;\n  readonly #breakpointItemToLocationMap =\n      new WeakMap<SourcesComponents.BreakpointsView.BreakpointItem, Bindings.BreakpointManager.BreakpointLocation[]>();\n  readonly #breakpointsActiveSetting: Common.Settings.Setting<boolean>;\n  readonly #pauseOnUncaughtExceptionSetting: Common.Settings.Setting<boolean>;\n  readonly #pauseOnCaughtExceptionSetting: Common.Settings.Setting<boolean>;\n\n  readonly #collapsedFilesSettings: Common.Settings.Setting<Platform.DevToolsPath.UrlString[]>;\n  readonly #collapsedFiles: Set<Platform.DevToolsPath.UrlString>;\n\n  #updateScheduled = false;\n  #updateRunning = false;\n\n  private constructor(\n      breakpointManager: Bindings.BreakpointManager.BreakpointManager, settings: Common.Settings.Settings) {\n    this.#collapsedFilesSettings = Common.Settings.Settings.instance().createSetting('collapsedFiles', []);\n    this.#collapsedFiles = new Set(this.#collapsedFilesSettings.get());\n    this.#breakpointManager = breakpointManager;\n    this.#breakpointManager.addEventListener(\n        Bindings.BreakpointManager.Events.BreakpointAdded, this.#onBreakpointAdded, this);\n    this.#breakpointManager.addEventListener(\n        Bindings.BreakpointManager.Events.BreakpointRemoved, this.#onBreakpointRemoved, this);\n    this.#breakpointsActiveSetting = settings.moduleSetting('breakpointsActive');\n    this.#breakpointsActiveSetting.addChangeListener(this.update, this);\n    this.#pauseOnUncaughtExceptionSetting = settings.moduleSetting('pauseOnUncaughtException');\n    this.#pauseOnUncaughtExceptionSetting.addChangeListener(this.update, this);\n    this.#pauseOnCaughtExceptionSetting = settings.moduleSetting('pauseOnCaughtException');\n    this.#pauseOnCaughtExceptionSetting.addChangeListener(this.update, this);\n  }\n\n  static instance({forceNew, breakpointManager, settings}: {\n    forceNew: boolean|null,\n    breakpointManager: Bindings.BreakpointManager.BreakpointManager,\n    settings: Common.Settings.Settings,\n  } = {\n    forceNew: null,\n    breakpointManager: Bindings.BreakpointManager.BreakpointManager.instance(),\n    settings: Common.Settings.Settings.instance(),\n  }): BreakpointsSidebarController {\n    if (!breakpointsViewControllerInstance || forceNew) {\n      breakpointsViewControllerInstance = new BreakpointsSidebarController(breakpointManager, settings);\n    }\n    return breakpointsViewControllerInstance;\n  }\n\n  static removeInstance(): void {\n    breakpointsViewControllerInstance = null;\n  }\n\n  static targetSupportsIndependentPauseOnExceptionToggles(): boolean {\n    const hasNodeTargets =\n        SDK.TargetManager.TargetManager.instance().targets().some(target => target.type() === SDK.Target.Type.Node);\n    return !hasNodeTargets;\n  }\n\n  flavorChanged(_object: Object|null): void {\n    void this.update();\n  }\n\n  breakpointStateChanged(breakpointItem: SourcesComponents.BreakpointsView.BreakpointItem, checked: boolean): void {\n    const locations = this.#getLocationsForBreakpointItem(breakpointItem);\n    locations.forEach((value: Bindings.BreakpointManager.BreakpointLocation) => {\n      const breakpoint = value.breakpoint;\n      breakpoint.setEnabled(checked);\n    });\n  }\n\n  async breakpointEdited(breakpointItem: SourcesComponents.BreakpointsView.BreakpointItem): Promise<void> {\n    const locations = this.#getLocationsForBreakpointItem(breakpointItem);\n    let location: Bindings.BreakpointManager.BreakpointLocation|undefined;\n    for (const locationCandidate of locations) {\n      if (!location || locationCandidate.uiLocation.compareTo(location.uiLocation) < 0) {\n        location = locationCandidate;\n      }\n    }\n    if (location) {\n      await Common.Revealer.reveal(location);\n    }\n  }\n\n  breakpointsRemoved(breakpointItems: SourcesComponents.BreakpointsView.BreakpointItem[]): void {\n    const locations = breakpointItems.flatMap(breakpointItem => this.#getLocationsForBreakpointItem(breakpointItem));\n    locations.forEach(location => location?.breakpoint.remove(false /* keepInStorage */));\n  }\n\n  expandedStateChanged(url: Platform.DevToolsPath.UrlString, expanded: boolean): void {\n    if (expanded) {\n      this.#collapsedFiles.delete(url);\n    } else {\n      this.#collapsedFiles.add(url);\n    }\n\n    this.#saveSettings();\n  }\n\n  async jumpToSource(breakpointItem: SourcesComponents.BreakpointsView.BreakpointItem): Promise<void> {\n    const uiLocations = this.#getLocationsForBreakpointItem(breakpointItem).map(location => location.uiLocation);\n    let uiLocation: Workspace.UISourceCode.UILocation|undefined;\n    for (const uiLocationCandidate of uiLocations) {\n      if (!uiLocation || uiLocationCandidate.compareTo(uiLocation) < 0) {\n        uiLocation = uiLocationCandidate;\n      }\n    }\n    if (uiLocation) {\n      await Common.Revealer.reveal(uiLocation);\n    }\n  }\n\n  setPauseOnUncaughtExceptions(value: boolean): void {\n    this.#pauseOnUncaughtExceptionSetting.set(value);\n  }\n\n  setPauseOnCaughtExceptions(value: boolean): void {\n    this.#pauseOnCaughtExceptionSetting.set(value);\n  }\n\n  async update(): Promise<void> {\n    this.#updateScheduled = true;\n    if (this.#updateRunning) {\n      return;\n    }\n    this.#updateRunning = true;\n    while (this.#updateScheduled) {\n      this.#updateScheduled = false;\n      const data = await this.getUpdatedBreakpointViewData();\n      BreakpointsSidebarPane.instance().data = data;\n    }\n    this.#updateRunning = false;\n  }\n\n  async getUpdatedBreakpointViewData(): Promise<SourcesComponents.BreakpointsView.BreakpointsViewData> {\n    const breakpointsActive = this.#breakpointsActiveSetting.get();\n    const independentPauseToggles = BreakpointsSidebarController.targetSupportsIndependentPauseOnExceptionToggles();\n    const pauseOnUncaughtExceptions = this.#pauseOnUncaughtExceptionSetting.get();\n    const pauseOnCaughtExceptions = this.#pauseOnCaughtExceptionSetting.get();\n\n    const breakpointLocations = this.#getBreakpointLocations();\n    if (!breakpointLocations.length) {\n      return {\n        breakpointsActive,\n        pauseOnCaughtExceptions,\n        pauseOnUncaughtExceptions,\n        independentPauseToggles,\n        groups: [],\n      };\n    }\n\n    const locationsGroupedById = this.#groupBreakpointLocationsById(breakpointLocations);\n    const locationIdsByLineId = this.#getLocationIdsByLineId(breakpointLocations);\n\n    const [content, selectedUILocation] = await Promise.all([\n      this.#getContent(locationsGroupedById),\n      this.#getHitUILocation(),\n    ]);\n\n    const urlToGroup = new Map<Platform.DevToolsPath.UrlString, SourcesComponents.BreakpointsView.BreakpointGroup>();\n\n    for (let idx = 0; idx < locationsGroupedById.length; idx++) {\n      const locations = locationsGroupedById[idx];\n      const fstLocation = locations[0];\n      const sourceURL = fstLocation.uiLocation.uiSourceCode.url();\n      const uiLocation = fstLocation.uiLocation;\n\n      const isHit = selectedUILocation !== null &&\n          locations.some(location => location.uiLocation.id() === selectedUILocation.id());\n\n      const numBreakpointsOnLine = locationIdsByLineId.get(uiLocation.lineId()).size;\n      const showColumn = numBreakpointsOnLine > 1;\n      const locationText = uiLocation.lineAndColumnText(showColumn) as string;\n\n      const text = content[idx];\n      const codeSnippet = text.lineAt(uiLocation.lineNumber);\n\n      if (isHit && this.#collapsedFiles.has(sourceURL)) {\n        this.#collapsedFiles.delete(sourceURL);\n        this.#saveSettings();\n      }\n      const expanded = !this.#collapsedFiles.has(sourceURL);\n\n      const status: SourcesComponents.BreakpointsView.BreakpointStatus = this.#getBreakpointState(locations);\n      const {type, hoverText} = this.#getBreakpointTypeAndDetails(locations);\n      const item = {\n        id: fstLocation.breakpoint.breakpointStorageId(),\n        location: locationText,\n        codeSnippet,\n        isHit,\n        status,\n        type,\n        hoverText,\n      };\n      this.#breakpointItemToLocationMap.set(item, locations);\n\n      let group = urlToGroup.get(sourceURL);\n      if (group) {\n        group.breakpointItems.push(item);\n        group.expanded ||= expanded;\n      } else {\n        const editable = this.#breakpointManager.supportsConditionalBreakpoints(uiLocation.uiSourceCode);\n        group = {\n          url: sourceURL,\n          name: uiLocation.uiSourceCode.displayName(),\n          editable,\n          expanded,\n          breakpointItems: [item],\n        };\n        urlToGroup.set(sourceURL, group);\n      }\n    }\n    return {\n      breakpointsActive,\n      pauseOnCaughtExceptions,\n      pauseOnUncaughtExceptions,\n      independentPauseToggles,\n      groups: Array.from(urlToGroup.values()),\n    };\n  }\n\n  #onBreakpointAdded(event: Common.EventTarget.EventTargetEvent<Bindings.BreakpointManager.BreakpointLocation>):\n      Promise<void> {\n    const breakpoint = event.data.breakpoint;\n    if (breakpoint.origin === Bindings.BreakpointManager.BreakpointOrigin.USER_ACTION &&\n        this.#collapsedFiles.has(breakpoint.url())) {\n      // Auto-expand if a new breakpoint was added to a collapsed group.\n      this.#collapsedFiles.delete(breakpoint.url());\n      this.#saveSettings();\n    }\n    return this.update();\n  }\n\n  #onBreakpointRemoved(event: Common.EventTarget.EventTargetEvent<Bindings.BreakpointManager.BreakpointLocation>):\n      Promise<void> {\n    const breakpoint = event.data.breakpoint;\n    if (this.#collapsedFiles.has(breakpoint.url())) {\n      const locations = Bindings.BreakpointManager.BreakpointManager.instance().allBreakpointLocations();\n      const otherBreakpointsOnSameFileExist =\n          locations.some(location => location.breakpoint.url() === breakpoint.url());\n      if (!otherBreakpointsOnSameFileExist) {\n        // Clear up the #collapsedFiles set from this url if no breakpoint is left in this group.\n        this.#collapsedFiles.delete(breakpoint.url());\n        this.#saveSettings();\n      }\n    }\n    return this.update();\n  }\n\n  #saveSettings(): void {\n    this.#collapsedFilesSettings.set(Array.from(this.#collapsedFiles.values()));\n  }\n\n  #getBreakpointTypeAndDetails(locations: Bindings.BreakpointManager.BreakpointLocation[]):\n      {type: SourcesComponents.BreakpointsView.BreakpointType, hoverText?: string} {\n    const breakpointWithCondition = locations.find(location => Boolean(location.breakpoint.condition()));\n    let hoverText = breakpointWithCondition?.breakpoint.condition();\n    let type = SourcesComponents.BreakpointsView.BreakpointType.REGULAR_BREAKPOINT;\n    if (breakpointWithCondition && hoverText) {\n      if (hoverText.startsWith(LogpointPrefix) && hoverText.endsWith(LogpointSuffix)) {\n        type = SourcesComponents.BreakpointsView.BreakpointType.LOGPOINT;\n        hoverText = hoverText.slice(LogpointPrefix.length, hoverText.length - LogpointSuffix.length);\n      } else {\n        type = SourcesComponents.BreakpointsView.BreakpointType.CONDITIONAL_BREAKPOINT;\n      }\n    }\n    return {type, hoverText};\n  }\n\n  #getLocationsForBreakpointItem(breakpointItem: SourcesComponents.BreakpointsView.BreakpointItem):\n      Bindings.BreakpointManager.BreakpointLocation[] {\n    const locations = this.#breakpointItemToLocationMap.get(breakpointItem);\n    assertNotNullOrUndefined(locations);\n    return locations;\n  }\n\n  async #getHitUILocation(): Promise<Workspace.UISourceCode.UILocation|null> {\n    const details = UI.Context.Context.instance().flavor(SDK.DebuggerModel.DebuggerPausedDetails);\n    if (details && details.callFrames.length) {\n      return await Bindings.DebuggerWorkspaceBinding.DebuggerWorkspaceBinding.instance().rawLocationToUILocation(\n          details.callFrames[0].location());\n    }\n    return null;\n  }\n\n  #getBreakpointLocations(): Bindings.BreakpointManager.BreakpointLocation[] {\n    const locations = this.#breakpointManager.allBreakpointLocations().filter(\n        breakpointLocation =>\n            breakpointLocation.uiLocation.uiSourceCode.project().type() !== Workspace.Workspace.projectTypes.Debugger);\n\n    locations.sort((item1, item2) => item1.uiLocation.compareTo(item2.uiLocation));\n\n    const result = [];\n    let lastBreakpoint: Bindings.BreakpointManager.Breakpoint|null = null;\n    let lastLocation: Workspace.UISourceCode.UILocation|null = null;\n    for (const location of locations) {\n      if (location.breakpoint !== lastBreakpoint || (lastLocation && location.uiLocation.compareTo(lastLocation))) {\n        result.push(location);\n        lastBreakpoint = location.breakpoint;\n        lastLocation = location.uiLocation;\n      }\n    }\n    return result;\n  }\n\n  #groupBreakpointLocationsById(breakpointLocations: Bindings.BreakpointManager.BreakpointLocation[]):\n      Bindings.BreakpointManager.BreakpointLocation[][] {\n    const map = new Platform.MapUtilities.Multimap<string, Bindings.BreakpointManager.BreakpointLocation>();\n    for (const breakpointLocation of breakpointLocations) {\n      const uiLocation = breakpointLocation.uiLocation;\n      map.set(uiLocation.id(), breakpointLocation);\n    }\n    const arr: Bindings.BreakpointManager.BreakpointLocation[][] = [];\n    for (const id of map.keysArray()) {\n      const locations = Array.from(map.get(id));\n      if (locations.length) {\n        arr.push(locations);\n      }\n    }\n    return arr;\n  }\n\n  #getLocationIdsByLineId(breakpointLocations: Bindings.BreakpointManager.BreakpointLocation[]):\n      Platform.MapUtilities.Multimap<string, string> {\n    const result = new Platform.MapUtilities.Multimap<string, string>();\n\n    for (const breakpointLocation of breakpointLocations) {\n      const uiLocation = breakpointLocation.uiLocation;\n      result.set(uiLocation.lineId(), uiLocation.id());\n    }\n\n    return result;\n  }\n\n  #getBreakpointState(locations: Bindings.BreakpointManager.BreakpointLocation[]):\n      SourcesComponents.BreakpointsView.BreakpointStatus {\n    const hasEnabled = locations.some(location => location.breakpoint.enabled());\n    const hasDisabled = locations.some(location => !location.breakpoint.enabled());\n    let status: SourcesComponents.BreakpointsView.BreakpointStatus;\n    if (hasEnabled) {\n      status = hasDisabled ? SourcesComponents.BreakpointsView.BreakpointStatus.INDETERMINATE :\n                             SourcesComponents.BreakpointsView.BreakpointStatus.ENABLED;\n    } else {\n      status = SourcesComponents.BreakpointsView.BreakpointStatus.DISABLED;\n    }\n    return status;\n  }\n\n  #getContent(locations: Bindings.BreakpointManager.BreakpointLocation[][]): Promise<TextUtils.Text.Text[]> {\n    // Use a cache to share the Text objects between all breakpoints. This way\n    // we share the cached line ending information that Text calculates. This\n    // was very slow to calculate with a lot of breakpoints in the same very\n    // large source file.\n    const contentToTextMap = new Map<string, TextUtils.Text.Text>();\n\n    return Promise.all(locations.map(async ([{uiLocation: {uiSourceCode}}]) => {\n      if (uiSourceCode.mimeType() === 'application/wasm') {\n        // We could mirror the logic from `SourceFrame._ensureContentLoaded()` here\n        // (and if so, ideally share that code somewhere), but that's quite heavy\n        // logic just to display a single Wasm instruction. Also not really clear\n        // how much value this would add. So let's keep it simple for now and don't\n        // display anything additional for Wasm breakpoints, and if there's demand\n        // to display some text preview, we could look into selectively disassemb-\n        // ling the part of the text that we need here.\n        // Relevant crbug: https://crbug.com/1090256\n        return new TextUtils.Text.Text('');\n      }\n      const {content} = await uiSourceCode.requestContent();\n      const contentText = content || '';\n      if (contentToTextMap.has(contentText)) {\n        return contentToTextMap.get(contentText) as TextUtils.Text.Text;\n      }\n      const text = new TextUtils.Text.Text(contentText);\n      contentToTextMap.set(contentText, text);\n      return text;\n    }));\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
