{
  "version": 3,
  "sources": ["../../../../../../../front_end/ui/components/linear_memory_inspector/LinearMemoryInspectorController.ts"],
  "sourcesContent": ["// Copyright 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Common from '../../../core/common/common.js';\nimport * as Host from '../../../core/host/host.js';\nimport * as i18n from '../../../core/i18n/i18n.js';\nimport * as SDK from '../../../core/sdk/sdk.js';\nimport * as Protocol from '../../../generated/protocol.js';\nimport * as UI from '../../legacy/legacy.js';\n\nimport {type Settings} from './LinearMemoryInspector.js';\nimport {Events as LmiEvents, LinearMemoryInspectorPaneImpl} from './LinearMemoryInspectorPane.js';\n\nimport {\n  Endianness,\n  getDefaultValueTypeMapping,\n  type ValueType,\n  type ValueTypeMode,\n} from './ValueInterpreterDisplayUtils.js';\nimport * as Bindings from '../../../models/bindings/bindings.js';\nimport {type HighlightInfo} from './LinearMemoryViewerUtils.js';\n\nconst UIStrings = {\n  /**\n   *@description Error message that shows up in the console if a buffer to be opened in the linear memory inspector cannot be found.\n   */\n  couldNotOpenLinearMemory: 'Could not open linear memory inspector: failed locating buffer.',\n};\nconst str_ =\n    i18n.i18n.registerUIStrings('ui/components/linear_memory_inspector/LinearMemoryInspectorController.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\nconst LINEAR_MEMORY_INSPECTOR_OBJECT_GROUP = 'linear-memory-inspector';\nconst MEMORY_TRANSFER_MIN_CHUNK_SIZE = 1000;\nexport const ACCEPTED_MEMORY_TYPES = ['webassemblymemory', 'typedarray', 'dataview', 'arraybuffer'];\n\nlet controllerInstance: LinearMemoryInspectorController;\n\nexport interface LazyUint8Array {\n  getRange(start: number, end: number): Promise<Uint8Array>;\n  length(): number;\n}\n\nexport class RemoteArrayBufferWrapper implements LazyUint8Array {\n  #remoteArrayBuffer: SDK.RemoteObject.RemoteArrayBuffer;\n\n  constructor(arrayBuffer: SDK.RemoteObject.RemoteArrayBuffer) {\n    this.#remoteArrayBuffer = arrayBuffer;\n  }\n\n  length(): number {\n    return this.#remoteArrayBuffer.byteLength();\n  }\n\n  async getRange(start: number, end: number): Promise<Uint8Array> {\n    const newEnd = Math.min(end, this.length());\n    if (start < 0 || start > newEnd) {\n      console.error(`Requesting invalid range of memory: (${start}, ${end})`);\n      return new Uint8Array(0);\n    }\n    const array = await this.#remoteArrayBuffer.bytes(start, newEnd);\n    return new Uint8Array(array);\n  }\n}\n\nasync function getBufferFromObject(obj: SDK.RemoteObject.RemoteObject): Promise<SDK.RemoteObject.RemoteArrayBuffer> {\n  console.assert(obj.type === 'object');\n  console.assert(obj.subtype !== undefined && ACCEPTED_MEMORY_TYPES.includes(obj.subtype));\n  const response = await obj.runtimeModel().agent.invoke_callFunctionOn({\n    objectId: obj.objectId,\n    functionDeclaration:\n        'function() { return this instanceof ArrayBuffer || (typeof SharedArrayBuffer !== \\'undefined\\' && this instanceof SharedArrayBuffer) ? this : this.buffer; }',\n    silent: true,\n    // Set object group in order to bind the object lifetime to the linear memory inspector.\n    objectGroup: LINEAR_MEMORY_INSPECTOR_OBJECT_GROUP,\n  });\n\n  const error = response.getError();\n  if (error) {\n    throw new Error(`Remote object representing ArrayBuffer could not be retrieved: ${error}`);\n  }\n  obj = obj.runtimeModel().createRemoteObject(response.result);\n  return new SDK.RemoteObject.RemoteArrayBuffer(obj);\n}\n\nexport function isDWARFMemoryObject(obj: SDK.RemoteObject.RemoteObject): boolean {\n  if (obj instanceof Bindings.DebuggerLanguagePlugins.ValueNode) {\n    return obj.inspectableAddress !== undefined;\n  }\n  if (obj instanceof Bindings.DebuggerLanguagePlugins.ExtensionRemoteObject) {\n    return obj.linearMemoryAddress !== undefined;\n  }\n  return false;\n}\n\nexport function isMemoryObjectProperty(obj: SDK.RemoteObject.RemoteObject): boolean {\n  const isWasmOrBuffer = obj.type === 'object' && obj.subtype && ACCEPTED_MEMORY_TYPES.includes(obj.subtype);\n  if (isWasmOrBuffer || isDWARFMemoryObject(obj)) {\n    return true;\n  }\n\n  return false;\n}\n\ntype SerializableSettings = {\n  valueTypes: ValueType[],\n  valueTypeModes: [ValueType, ValueTypeMode][],\n  endianness: Endianness,\n};\n\nexport class LinearMemoryInspectorController extends SDK.TargetManager.SDKModelObserver<SDK.RuntimeModel.RuntimeModel> {\n  #paneInstance = LinearMemoryInspectorPaneImpl.instance();\n  #bufferIdToRemoteObject: Map<string, SDK.RemoteObject.RemoteObject> = new Map();\n  #bufferIdToHighlightInfo: Map<string, HighlightInfo> = new Map();\n  #settings: Common.Settings.Setting<SerializableSettings>;\n\n  private constructor() {\n    super();\n    SDK.TargetManager.TargetManager.instance().observeModels(SDK.RuntimeModel.RuntimeModel, this);\n    SDK.TargetManager.TargetManager.instance().addModelListener(\n        SDK.DebuggerModel.DebuggerModel, SDK.DebuggerModel.Events.GlobalObjectCleared, this.#onGlobalObjectClear, this);\n    this.#paneInstance.addEventListener(LmiEvents.ViewClosed, this.#viewClosed.bind(this));\n\n    SDK.TargetManager.TargetManager.instance().addModelListener(\n        SDK.DebuggerModel.DebuggerModel, SDK.DebuggerModel.Events.DebuggerPaused, this.#onDebuggerPause, this);\n\n    const defaultValueTypeModes = getDefaultValueTypeMapping();\n    const defaultSettings: SerializableSettings = {\n      valueTypes: Array.from(defaultValueTypeModes.keys()),\n      valueTypeModes: Array.from(defaultValueTypeModes),\n      endianness: Endianness.Little,\n    };\n    this.#settings = Common.Settings.Settings.instance().createSetting('lmiInterpreterSettings', defaultSettings);\n  }\n\n  static instance(): LinearMemoryInspectorController {\n    if (controllerInstance) {\n      return controllerInstance;\n    }\n    controllerInstance = new LinearMemoryInspectorController();\n    return controllerInstance;\n  }\n\n  static async getMemoryForAddress(memoryWrapper: LazyUint8Array, address: number):\n      Promise<{memory: Uint8Array, offset: number}> {\n    // Provide a chunk of memory that covers the address to show and some before and after\n    // as 1. the address shown is not necessarily at the beginning of a page and\n    // 2. to allow for fewer memory requests.\n    const memoryChunkStart = Math.max(0, address - MEMORY_TRANSFER_MIN_CHUNK_SIZE / 2);\n    const memoryChunkEnd = memoryChunkStart + MEMORY_TRANSFER_MIN_CHUNK_SIZE;\n    const memory = await memoryWrapper.getRange(memoryChunkStart, memoryChunkEnd);\n    return {memory: memory, offset: memoryChunkStart};\n  }\n\n  static async getMemoryRange(memoryWrapper: LazyUint8Array, start: number, end: number): Promise<Uint8Array> {\n    // Check that the requested start is within bounds.\n    // If the requested end is larger than the actual\n    // memory, it will be automatically capped when\n    // requesting the range.\n    if (start < 0 || start > end || start >= memoryWrapper.length()) {\n      throw new Error('Requested range is out of bounds.');\n    }\n    const chunkEnd = Math.max(end, start + MEMORY_TRANSFER_MIN_CHUNK_SIZE);\n    return await memoryWrapper.getRange(start, chunkEnd);\n  }\n\n  async evaluateExpression(callFrame: SDK.DebuggerModel.CallFrame, expressionName: string):\n      Promise<SDK.RemoteObject.RemoteObject|undefined> {\n    const result = await callFrame.evaluate({expression: expressionName});\n    if ('error' in result) {\n      console.error(`Tried to evaluate the expression '${expressionName}' but got an error: ${result.error}`);\n      return undefined;\n    }\n    if ('exceptionDetails' in result && result?.exceptionDetails?.text) {\n      console.error(\n          `Tried to evaluate the expression '${expressionName}' but got an exception: ${result.exceptionDetails.text}`);\n      return undefined;\n    }\n    return result.object;\n  }\n\n  saveSettings(data: Settings): void {\n    const valueTypes = Array.from(data.valueTypes);\n    const modes = [...data.modes];\n    this.#settings.set({valueTypes, valueTypeModes: modes, endianness: data.endianness});\n  }\n\n  loadSettings(): Settings {\n    const settings = this.#settings.get();\n    return {\n      valueTypes: new Set(settings.valueTypes),\n      modes: new Map(settings.valueTypeModes),\n      endianness: settings.endianness,\n    };\n  }\n\n  getHighlightInfo(bufferId: string): HighlightInfo|undefined {\n    return this.#bufferIdToHighlightInfo.get(bufferId);\n  }\n\n  removeHighlight(bufferId: string, highlightInfo: HighlightInfo): void {\n    const currentHighlight = this.getHighlightInfo(bufferId);\n    if (currentHighlight === highlightInfo) {\n      this.#bufferIdToHighlightInfo.delete(bufferId);\n    }\n  }\n\n  setHighlightInfo(bufferId: string, highlightInfo: HighlightInfo): void {\n    this.#bufferIdToHighlightInfo.set(bufferId, highlightInfo);\n  }\n\n  #resetHighlightInfo(bufferId: string): void {\n    this.#bufferIdToHighlightInfo.delete(bufferId);\n  }\n\n  static async retrieveDWARFMemoryObjectAndAddress(obj: SDK.RemoteObject.RemoteObject):\n      Promise<{obj: SDK.RemoteObject.RemoteObject, address: number}|undefined> {\n    if (obj instanceof Bindings.DebuggerLanguagePlugins.ExtensionRemoteObject) {\n      const valueNode = obj;\n      const address = obj.linearMemoryAddress;\n      if (address === undefined) {\n        return undefined;\n      }\n      const callFrame = valueNode.callFrame;\n      const response = await obj.debuggerModel().agent.invoke_evaluateOnCallFrame({\n        callFrameId: callFrame.id,\n        expression: 'memories[0]',\n      });\n      const error = response.getError();\n      if (error) {\n        console.error(error);\n        Common.Console.Console.instance().error(i18nString(UIStrings.couldNotOpenLinearMemory));\n      }\n      const runtimeModel = obj.debuggerModel().runtimeModel();\n      return {obj: runtimeModel.createRemoteObject(response.result), address};\n    }\n    if (!(obj instanceof Bindings.DebuggerLanguagePlugins.ValueNode)) {\n      return undefined;\n    }\n\n    const valueNode = obj;\n    const address = valueNode.inspectableAddress || 0;\n    const callFrame = valueNode.callFrame;\n    const response = await obj.debuggerModel().agent.invoke_evaluateOnCallFrame({\n      callFrameId: callFrame.id,\n      expression: 'memories[0]',\n    });\n    const error = response.getError();\n    if (error) {\n      console.error(error);\n      Common.Console.Console.instance().error(i18nString(UIStrings.couldNotOpenLinearMemory));\n    }\n    const runtimeModel = obj.debuggerModel().runtimeModel();\n    obj = runtimeModel.createRemoteObject(response.result);\n    return {obj, address};\n  }\n\n  // This function returns the size of the source language value represented by the ValueNode or ExtensionRemoteObject.\n  // If the value is a pointer, the function returns the size of the pointed-to value. If the pointed-to value is also a\n  // pointer, it returns the size of the pointer (usually 4 bytes). This is the convention taken by the DWARF extension.\n  // > double x = 42.0;\n  // > double *ptr = &x;\n  // > double **dblptr = &ptr;\n  //\n  // retrieveObjectSize(ptr_ValueNode) -> 8, the size of a double\n  // retrieveObjectSize(dblptr_ValueNode) -> 4, the size of a pointer\n  static extractObjectSize(obj: Bindings.DebuggerLanguagePlugins.ValueNode|\n                           Bindings.DebuggerLanguagePlugins.ExtensionRemoteObject): number {\n    if (obj instanceof Bindings.DebuggerLanguagePlugins.ExtensionRemoteObject) {\n      return obj.linearMemorySize ?? 0;\n    }\n    let typeInfo = obj.sourceType.typeInfo;\n    const pointerMembers = typeInfo.members.filter(member => member.name === '*');\n    if (pointerMembers.length === 1) {\n      const typeId = pointerMembers[0].typeId;\n      const newTypeInfo = obj.sourceType.typeMap.get(typeId)?.typeInfo;\n      if (newTypeInfo !== undefined) {\n        typeInfo = newTypeInfo;\n      } else {\n        throw new Error(`Cannot find the source type information for typeId ${typeId}.`);\n      }\n    } else if (pointerMembers.length > 1) {\n      throw new Error('The number of pointers in typeInfo.members should not be greater than one.');\n    }\n    return typeInfo.size;\n  }\n\n  // The object type description corresponds to the type of the highlighted memory\n  // that the user sees in the memory inspector. For pointers, we highlight the pointed to object.\n  //\n  // Example: The variable `x` has the type `int *`. Assume that `x` points to the value 3.\n  // -> The memory inspector will jump to the address where 3 is stored.\n  // -> The memory inspector will highlight the bytes that represent the 3.\n  // -> The object type description of what we show will thus be `int` and not `int *`.\n  static extractObjectTypeDescription(obj: SDK.RemoteObject.RemoteObject): string {\n    const objType = obj.description;\n    if (!objType) {\n      return '';\n    }\n    const lastChar = objType.charAt(objType.length - 1);\n    const secondToLastChar = objType.charAt(objType.length - 2);\n    const isPointerType = lastChar === '*' || lastChar === '&';\n    const isOneLevelPointer = secondToLastChar === ' ';\n    if (!isPointerType) {\n      return objType;\n    }\n    if (isOneLevelPointer) {\n      // For example, 'int *'and 'int &' become 'int'.\n      return objType.slice(0, objType.length - 2);\n    }\n    // For example, 'int **' becomes 'int *'.\n    return objType.slice(0, objType.length - 1);\n  }\n\n  // When inspecting a pointer variable, we indicate that we display the pointed-to object in the viewer\n  // by prepending an asterisk to the pointer expression's name (mimicking C++ dereferencing).\n  // If the object isn't a pointer, we return the expression unchanged.\n  //\n  // Examples:\n  // (int *) myNumber -> (int) *myNumber\n  // (int[]) numbers -> (int[]) numbers\n  static extractObjectName(obj: SDK.RemoteObject.RemoteObject, expression: string): string {\n    const lastChar = obj.description?.charAt(obj.description.length - 1);\n    const isPointerType = lastChar === '*';\n    if (isPointerType) {\n      return '*' + expression;\n    }\n    return expression;\n  }\n\n  async openInspectorView(obj: SDK.RemoteObject.RemoteObject, address?: number, expression?: string): Promise<void> {\n    const response = await LinearMemoryInspectorController.retrieveDWARFMemoryObjectAndAddress(obj);\n    let memoryObj = obj;\n    let memoryAddress = address;\n    if (response !== undefined) {\n      memoryAddress = response.address;\n      memoryObj = response.obj;\n    }\n\n    if (memoryAddress !== undefined) {\n      Host.userMetrics.linearMemoryInspectorTarget(\n          Host.UserMetrics.LinearMemoryInspectorTarget.DWARFInspectableAddress);\n    } else if (memoryObj.subtype === Protocol.Runtime.RemoteObjectSubtype.Arraybuffer) {\n      Host.userMetrics.linearMemoryInspectorTarget(Host.UserMetrics.LinearMemoryInspectorTarget.ArrayBuffer);\n    } else if (memoryObj.subtype === Protocol.Runtime.RemoteObjectSubtype.Dataview) {\n      Host.userMetrics.linearMemoryInspectorTarget(Host.UserMetrics.LinearMemoryInspectorTarget.DataView);\n    } else if (memoryObj.subtype === Protocol.Runtime.RemoteObjectSubtype.Typedarray) {\n      Host.userMetrics.linearMemoryInspectorTarget(Host.UserMetrics.LinearMemoryInspectorTarget.TypedArray);\n    } else {\n      console.assert(memoryObj.subtype === Protocol.Runtime.RemoteObjectSubtype.Webassemblymemory);\n      Host.userMetrics.linearMemoryInspectorTarget(Host.UserMetrics.LinearMemoryInspectorTarget.WebAssemblyMemory);\n    }\n    const buffer = await getBufferFromObject(memoryObj);\n    const {internalProperties} = await buffer.object().getOwnProperties(false);\n    const idProperty = internalProperties?.find(({name}) => name === '[[ArrayBufferData]]');\n    const id = idProperty?.value?.value;\n    if (!id) {\n      throw new Error('Unable to find backing store id for array buffer');\n    }\n    const memoryProperty = internalProperties?.find(({name}) => name === '[[WebAssemblyMemory]]');\n    const memory = memoryProperty?.value;\n    const highlightInfo = LinearMemoryInspectorController.extractHighlightInfo(obj, expression);\n    if (highlightInfo) {\n      this.setHighlightInfo(id, highlightInfo);\n    } else {\n      this.#resetHighlightInfo(id);\n    }\n    if (this.#bufferIdToRemoteObject.has(id)) {\n      this.#paneInstance.reveal(id, memoryAddress);\n      void UI.ViewManager.ViewManager.instance().showView('linear-memory-inspector');\n      return;\n    }\n\n    const title = String(memory ? memory.description : buffer.object().description);\n    this.#bufferIdToRemoteObject.set(id, buffer.object());\n    const arrayBufferWrapper = new RemoteArrayBufferWrapper(buffer);\n\n    this.#paneInstance.create(id, title, arrayBufferWrapper, memoryAddress);\n    void UI.ViewManager.ViewManager.instance().showView('linear-memory-inspector');\n  }\n\n  static extractHighlightInfo(obj: SDK.RemoteObject.RemoteObject, expression?: string): HighlightInfo|undefined {\n    if (!(obj instanceof Bindings.DebuggerLanguagePlugins.ValueNode) &&\n        !(obj instanceof Bindings.DebuggerLanguagePlugins.ExtensionRemoteObject)) {\n      return undefined;\n    }\n\n    const startAddress =\n        (obj instanceof Bindings.DebuggerLanguagePlugins.ExtensionRemoteObject ? obj.linearMemoryAddress :\n                                                                                 obj.inspectableAddress) ??\n        0;\n\n    let highlightInfo;\n    try {\n      highlightInfo = {\n        startAddress,\n        size: LinearMemoryInspectorController.extractObjectSize(obj),\n        name: expression ? LinearMemoryInspectorController.extractObjectName(obj, expression) : expression,\n        type: LinearMemoryInspectorController.extractObjectTypeDescription(obj),\n      };\n    } catch (err) {\n      highlightInfo = undefined;\n    }\n    return highlightInfo;\n  }\n\n  modelRemoved(model: SDK.RuntimeModel.RuntimeModel): void {\n    for (const [bufferId, remoteObject] of this.#bufferIdToRemoteObject) {\n      if (model === remoteObject.runtimeModel()) {\n        this.#bufferIdToRemoteObject.delete(bufferId);\n        this.#resetHighlightInfo(bufferId);\n        this.#paneInstance.close(bufferId);\n      }\n    }\n  }\n\n  #onDebuggerPause(event: Common.EventTarget.EventTargetEvent<SDK.DebuggerModel.DebuggerModel>): void {\n    const debuggerModel = event.data;\n    for (const [bufferId, remoteObject] of this.#bufferIdToRemoteObject) {\n      if (debuggerModel.runtimeModel() === remoteObject.runtimeModel()) {\n        const topCallFrame = debuggerModel.debuggerPausedDetails()?.callFrames[0];\n        if (topCallFrame) {\n          void this\n              .updateHighlightedMemory(bufferId, topCallFrame)\n              // Need to call refreshView in the callback to trigger re-render.\n              .then(() => this.#paneInstance.refreshView(bufferId));\n        } else {\n          this.#resetHighlightInfo(bufferId);\n          this.#paneInstance.refreshView(bufferId);\n        }\n      }\n    }\n  }\n\n  #onGlobalObjectClear(event: Common.EventTarget.EventTargetEvent<SDK.DebuggerModel.DebuggerModel>): void {\n    this.modelRemoved(event.data.runtimeModel());\n  }\n\n  #viewClosed({data: bufferId}: Common.EventTarget.EventTargetEvent<string>): void {\n    const remoteObj = this.#bufferIdToRemoteObject.get(bufferId);\n    if (remoteObj) {\n      remoteObj.release();\n    }\n    this.#bufferIdToRemoteObject.delete(bufferId);\n    this.#resetHighlightInfo(bufferId);\n  }\n\n  async updateHighlightedMemory(bufferId: string, callFrame: SDK.DebuggerModel.CallFrame): Promise<void> {\n    const oldHighlightInfo = this.getHighlightInfo(bufferId);\n    const expressionName = oldHighlightInfo?.name;\n    if (!oldHighlightInfo || !expressionName) {\n      this.#resetHighlightInfo(bufferId);\n      return;\n    }\n    const obj = await this.evaluateExpression(callFrame, expressionName);\n    if (!obj) {\n      this.#resetHighlightInfo(bufferId);\n      return;\n    }\n\n    const newHighlightInfo = LinearMemoryInspectorController.extractHighlightInfo(obj, expressionName);\n    if (!newHighlightInfo || !this.#pointToSameMemoryObject(newHighlightInfo, oldHighlightInfo)) {\n      this.#resetHighlightInfo(bufferId);\n    } else {\n      this.setHighlightInfo(bufferId, newHighlightInfo);\n    }\n  }\n\n  #pointToSameMemoryObject(highlightInfoA: HighlightInfo, highlightInfoB: HighlightInfo): boolean {\n    return highlightInfoA.type === highlightInfoB.type && highlightInfoA.startAddress === highlightInfoB.startAddress;\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
