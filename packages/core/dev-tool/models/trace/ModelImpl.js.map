{
  "version": 3,
  "sources": ["../../../../../../front_end/models/trace/ModelImpl.ts"],
  "sourcesContent": ["// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../core/platform/platform.js';\n\nimport * as Handlers from './handlers/handlers.js';\nimport * as Helpers from './helpers/helpers.js';\nimport {TraceProcessor} from './TraceProcessor.js';\n\nimport type * as Types from './types/types.js';\n\n// Note: this model is implemented in a way that can support multiple trace\n// processors. Currently there is only one implemented, but you will see\n// references to \"processors\" plural because it can easily be extended in the future.\n\nexport class Model extends EventTarget {\n  readonly #traceProcessor = new TraceProcessor(Handlers.ModelHandlers);\n  readonly #traces: ParsedTraceFile[] = [];\n  readonly #nextNumberByDomain = new Map<string, number>();\n\n  readonly #recordingsAvailable: string[] = [];\n  #lastRecordingIndex = 0;\n\n  async parse(\n      traceEvents: readonly Types.TraceEvents.TraceEventData[], metadata: TraceFileMetaData = {},\n      freshRecording = false): Promise<void> {\n    // During parsing, periodically update any listeners on each processors'\n    // progress (if they have any updates).\n    const onTraceUpdate = (event: Event): void => {\n      const {data} = event as TraceParseEvent;\n      this.dispatchEvent(new ModelUpdateEvent({type: ModelUpdateType.TRACE, data: data}));\n    };\n\n    this.#traceProcessor.addEventListener(TraceParseEvent.eventName, onTraceUpdate);\n\n    // Create a parsed trace file, populating it in parallel as each processor\n    // finishes its parsing process.\n\n    const file: ParsedTraceFile = {\n      traceEvents,\n      metadata,\n      traceParsedData: null,\n    };\n\n    // When processors have finished parsing, store the parsed data so that it\n    // is available to call sites notified by each respective 'done' update.\n\n    const traceProcessing = async(): Promise<void> => {\n      await this.#traceProcessor.parse(traceEvents, freshRecording);\n      file.traceParsedData = this.#traceProcessor.data;\n      this.#lastRecordingIndex++;\n      let recordingName = `Trace ${this.#lastRecordingIndex}`;\n      let origin: string|null = null;\n      if (file.traceParsedData) {\n        origin = Helpers.Trace.extractOriginFromTrace(file.traceParsedData.Meta.mainFrameURL);\n        if (origin) {\n          const nextSequenceForDomain = Platform.MapUtilities.getWithDefault(this.#nextNumberByDomain, origin, () => 1);\n          recordingName = `${origin} (${nextSequenceForDomain})`;\n          this.#nextNumberByDomain.set(origin, nextSequenceForDomain + 1);\n        }\n      }\n      this.#recordingsAvailable.push(recordingName);\n      this.dispatchEvent(new ModelUpdateEvent({type: ModelUpdateType.TRACE, data: 'done'}));\n    };\n\n    try {\n      // Wait for all outstanding promises before finishing the async execution,\n      // but perform all tasks in parallel.\n      await traceProcessing();\n      // We only push the file onto this.#traces here once we know it's valid\n      // and there's been no errors in the parsing.\n      this.#traces.push(file);\n    } catch (e) {\n      throw e;\n    } finally {\n      // All processors have finished parsing, no more updates are expected.\n      // Finally, update any listeners that all processors are 'done'.\n      this.#traceProcessor.removeEventListener(TraceParseEvent.eventName, onTraceUpdate);\n      this.dispatchEvent(new ModelUpdateEvent({type: ModelUpdateType.GLOBAL, data: 'done'}));\n    }\n  }\n\n  traceParsedData(index: number): Handlers.Types.TraceParseData|null {\n    if (!this.#traces[index]) {\n      return null;\n    }\n\n    return this.#traces[index].traceParsedData;\n  }\n\n  metadata(index: number): TraceFileMetaData|null {\n    if (!this.#traces[index]) {\n      return null;\n    }\n\n    return this.#traces[index].metadata;\n  }\n\n  traceEvents(index: number): readonly Types.TraceEvents.TraceEventData[]|null {\n    if (!this.#traces[index]) {\n      return null;\n    }\n\n    return this.#traces[index].traceEvents;\n  }\n\n  size(): number {\n    return this.#traces.length;\n  }\n\n  deleteTraceByIndex(recordingIndex: number): void {\n    this.#traces.splice(recordingIndex, 1);\n    this.#recordingsAvailable.splice(recordingIndex, 1);\n  }\n\n  getRecordingsAvailable(): string[] {\n    return this.#recordingsAvailable;\n  }\n\n  reset(): void {\n    this.#traceProcessor.reset();\n  }\n}\n\n/**\n * This parsed trace file is used by the Model. It keeps multiple instances\n * of these so that the user can swap between them. The key is that it is\n * essentially the TraceFile plus whatever the model has parsed from it.\n */\nexport type ParsedTraceFile = TraceFile&{\n  traceParsedData: Handlers.Types.TraceParseData | null,\n};\n\nexport const enum ModelUpdateType {\n  GLOBAL = 0,\n  TRACE = 1,\n  LIGHTHOUSE = 2,\n}\n\nexport type ModelUpdateEventData = ModelUpdateEventGlobalData|ModelUpdateEventTraceData|ModelUpdateEventLighthouseData;\n\nexport type ModelUpdateEventGlobalData = {\n  type: ModelUpdateType.GLOBAL,\n  data: GlobalParseEventData,\n};\n\nexport type ModelUpdateEventTraceData = {\n  type: ModelUpdateType.TRACE,\n  data: TraceParseEventData,\n};\n\nexport type ModelUpdateEventLighthouseData = {\n  type: ModelUpdateType.LIGHTHOUSE,\n  data: LighthouseParseEventData,\n};\n\nexport type GlobalParseEventData = 'done';\nexport type TraceParseEventData = TraceParseEventProgressData|'done';\nexport type LighthouseParseEventData = 'done';\n\nexport type TraceParseEventProgressData = {\n  index: number,\n  total: number,\n};\n\nexport class ModelUpdateEvent extends Event {\n  static readonly eventName = 'modelupdate';\n  constructor(public data: ModelUpdateEventData) {\n    super(ModelUpdateEvent.eventName);\n  }\n}\n\nexport function isModelUpdateEventDataGlobal(object: ModelUpdateEventData): object is ModelUpdateEventGlobalData {\n  return object.type === ModelUpdateType.GLOBAL;\n}\n\nexport function isModelUpdateEventDataTrace(object: ModelUpdateEventData): object is ModelUpdateEventTraceData {\n  return object.type === ModelUpdateType.TRACE;\n}\n\nexport class TraceParseEvent extends Event {\n  static readonly eventName = 'traceparse';\n  constructor(public data: TraceParseEventData, init: EventInit = {bubbles: true}) {\n    super(TraceParseEvent.eventName, init);\n  }\n}\n\nexport type TraceFile = {\n  traceEvents: readonly Types.TraceEvents.TraceEventData[],\n  metadata: TraceFileMetaData,\n};\n\n/**\n * Trace metadata that we persist to the file. This will allow us to\n * store specifics for the trace, e.g., which tracks should be visible\n * on load.\n */\nexport interface TraceFileMetaData {\n  source?: 'DevTools';\n  networkThrottling?: string;\n  cpuThrottling?: number;\n}\n\nexport type TraceFileContents = TraceFile|Types.TraceEvents.TraceEventData[];\n\ndeclare global {\n  interface HTMLElementEventMap {\n    [TraceParseEvent.eventName]: TraceParseEvent;\n  }\n}\n"],
  "mappings": "AAIA;AAEA;AACA;AACA;AAQO,2BAAoB,YAAY;AAAA,oBACV,IAAI,eAAe,SAAS;AAAA,YACjB;AAAA,wBACP,oBAAI;AAAA,yBAEO;AAAA,wBACpB;AAAA,QAEhB,MACF,aAA0D,WAA8B,IACxF,iBAAiB,OAAsB;AAGzC,UAAM,gBAAgB,CAAC,UAAuB;AAC5C,YAAM,EAAC,SAAQ;AACf,WAAK,cAAc,IAAI,iBAAiB,EAAC,MAAM,gBAAgB,OAAO;AAAA;AAGxE,yBAAqB,iBAAiB,gBAAgB,WAAW;AAKjE,UAAM,OAAwB;AAAA,MAC5B;AAAA,MACA;AAAA,MACA,iBAAiB;AAAA;AAMnB,UAAM,kBAAkB,YAA0B;AAChD,YAAM,qBAAqB,MAAM,aAAa;AAC9C,WAAK,kBAAkB,qBAAqB;AAC5C;AACA,UAAI,gBAAgB,SAAS;AAC7B,UAAI,SAAsB;AAC1B,UAAI,KAAK,iBAAiB;AACxB,iBAAS,QAAQ,MAAM,uBAAuB,KAAK,gBAAgB,KAAK;AACxE,YAAI,QAAQ;AACV,gBAAM,wBAAwB,SAAS,aAAa,eAAe,0BAA0B,QAAQ,MAAM;AAC3G,0BAAgB,GAAG,WAAW;AAC9B,mCAAyB,IAAI,QAAQ,wBAAwB;AAAA;AAAA;AAGjE,gCAA0B,KAAK;AAC/B,WAAK,cAAc,IAAI,iBAAiB,EAAC,MAAM,gBAAgB,OAAO,MAAM;AAAA;AAG9E,QAAI;AAGF,YAAM;AAGN,mBAAa,KAAK;AAAA,aACX,GAAP;AACA,YAAM;AAAA,cACN;AAGA,2BAAqB,oBAAoB,gBAAgB,WAAW;AACpE,WAAK,cAAc,IAAI,iBAAiB,EAAC,MAAM,gBAAgB,QAAQ,MAAM;AAAA;AAAA;AAAA,EAIjF,gBAAgB,OAAmD;AACjE,QAAI,CAAC,aAAa,QAAQ;AACxB,aAAO;AAAA;AAGT,WAAO,aAAa,OAAO;AAAA;AAAA,EAG7B,SAAS,OAAuC;AAC9C,QAAI,CAAC,aAAa,QAAQ;AACxB,aAAO;AAAA;AAGT,WAAO,aAAa,OAAO;AAAA;AAAA,EAG7B,YAAY,OAAiE;AAC3E,QAAI,CAAC,aAAa,QAAQ;AACxB,aAAO;AAAA;AAGT,WAAO,aAAa,OAAO;AAAA;AAAA,EAG7B,OAAe;AACb,WAAO,aAAa;AAAA;AAAA,EAGtB,mBAAmB,gBAA8B;AAC/C,iBAAa,OAAO,gBAAgB;AACpC,8BAA0B,OAAO,gBAAgB;AAAA;AAAA,EAGnD,yBAAmC;AACjC,WAAO;AAAA;AAAA,EAGT,QAAc;AACZ,yBAAqB;AAAA;AAAA;AAalB,WAAW,kBAAX,kBAAW,qBAAX;AACL,gDAAS,KAAT;AACA,+CAAQ,KAAR;AACA,oDAAa,KAAb;AAHgB;AAAA;AAgCX,sCAA+B,MAAM;AAAA,EAE1C,YAAmB,MAA4B;AAC7C,UAAM,iBAAiB;AADN;AAAA;AAAA,SADH,YAAY;AAAA;AAMvB,6CAAsC,QAAoE;AAC/G,SAAO,OAAO,SAAS;AAAA;AAGlB,4CAAqC,QAAmE;AAC7G,SAAO,OAAO,SAAS;AAAA;AAGlB,qCAA8B,MAAM;AAAA,EAEzC,YAAmB,MAA2B,OAAkB,EAAC,SAAS,QAAO;AAC/E,UAAM,gBAAgB,WAAW;AADhB;AAAA;AAAA,SADH,YAAY;AAAA;",
  "names": []
}
