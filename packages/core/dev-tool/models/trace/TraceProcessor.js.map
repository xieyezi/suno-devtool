{
  "version": 3,
  "sources": ["../../../../../../front_end/models/trace/TraceProcessor.ts"],
  "sourcesContent": ["// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Handlers from './handlers/handlers.js';\nimport type * as Types from './types/types.js';\n\nimport {type TraceParseEventProgressData, TraceParseEvent} from './ModelImpl.js';\nconst enum Status {\n  IDLE = 0,\n  PARSING = 1,\n  FINISHED_PARSING = 2,\n  ERRORED_WHILE_PARSING = 3,\n}\n\nexport class TraceProcessor<ModelHandlers extends {[key: string]: Handlers.Types.TraceEventHandler}> extends\n    EventTarget {\n  readonly #traceHandlers: {[key: string]: Handlers.Types.TraceEventHandler};\n  #pauseDuration: number;\n  #pauseFrequencyMs: number;\n  #status = Status.IDLE;\n\n  constructor(traceHandlers: ModelHandlers, {pauseDuration = 20, pauseFrequencyMs = 100} = {}) {\n    super();\n\n    this.#traceHandlers = traceHandlers;\n    this.#pauseDuration = pauseDuration;\n    this.#pauseFrequencyMs = pauseFrequencyMs;\n  }\n\n  reset(): void {\n    if (this.#status === Status.PARSING) {\n      throw new Error('Trace processor can\\'t reset while parsing.');\n    }\n\n    const handlers = Object.values(this.#traceHandlers);\n    for (const handler of handlers) {\n      handler.reset();\n    }\n\n    this.#status = Status.IDLE;\n  }\n\n  async parse(traceEvents: readonly Types.TraceEvents.TraceEventData[], freshRecording = false): Promise<void> {\n    if (this.#status !== Status.IDLE) {\n      throw new Error('Trace processor can\\'t start parsing when not idle.');\n    }\n    try {\n      this.#status = Status.PARSING;\n      await this.#parse(traceEvents, freshRecording);\n      this.#status = Status.FINISHED_PARSING;\n    } catch (e) {\n      this.#status = Status.ERRORED_WHILE_PARSING;\n      throw e;\n    }\n  }\n\n  async #parse(traceEvents: readonly Types.TraceEvents.TraceEventData[], freshRecording: boolean): Promise<void> {\n    // This iterator steps through all events, periodically yielding back to the\n    // main thread to avoid blocking execution. It uses `dispatchEvent` to\n    // provide status update events, and other various bits of config like the\n    // pause duration and frequency.\n    const traceEventIterator = new TraceEventIterator(traceEvents, this.#pauseDuration, this.#pauseFrequencyMs);\n\n    // Convert to array so that we are able to iterate all handlers multiple times.\n    const sortedHandlers = [...sortHandlers(this.#traceHandlers).values()];\n    // Reset.\n    for (const handler of sortedHandlers) {\n      handler.reset();\n    }\n\n    // Initialize.\n    for (const handler of sortedHandlers) {\n      handler.initialize?.(freshRecording);\n    }\n\n    // Handle each event.\n    for await (const item of traceEventIterator) {\n      if (item.kind === IteratorItemType.STATUS_UPDATE) {\n        this.dispatchEvent(new TraceParseEvent(item.data));\n        continue;\n      }\n      for (const handler of sortedHandlers) {\n        handler.handleEvent(item.data);\n      }\n    }\n\n    // Finalize.\n    for (const handler of sortedHandlers) {\n      await handler.finalize?.();\n    }\n  }\n\n  get data(): Handlers.Types.HandlerData<ModelHandlers>|null {\n    if (this.#status !== Status.FINISHED_PARSING) {\n      return null;\n    }\n\n    const data = {};\n    for (const [name, handler] of Object.entries(this.#traceHandlers)) {\n      Object.assign(data, {[name]: handler.data()});\n    }\n\n    return data as Handlers.Types.HandlerData<ModelHandlers>;\n  }\n}\n\n/**\n * Some Handlers need data provided by others. Dependencies of a handler handler are\n * declared in the `deps` field.\n * @returns A map from trace event handler name to trace event hander whose entries\n * iterate in such a way that each handler is visited after its dependencies.\n */\nexport function sortHandlers(\n    traceHandlers: Partial<{[key in Handlers.Types.TraceEventHandlerName]: Handlers.Types.TraceEventHandler}>):\n    Map<Handlers.Types.TraceEventHandlerName, Handlers.Types.TraceEventHandler> {\n  const sortedMap = new Map<Handlers.Types.TraceEventHandlerName, Handlers.Types.TraceEventHandler>();\n  const visited = new Set<Handlers.Types.TraceEventHandlerName>();\n  const visitHandler = (handlerName: Handlers.Types.TraceEventHandlerName): void => {\n    if (sortedMap.has(handlerName)) {\n      return;\n    }\n    if (visited.has(handlerName)) {\n      let stackPath = '';\n      for (const handler of visited) {\n        if (stackPath || handler === handlerName) {\n          stackPath += `${handler}->`;\n        }\n      }\n      stackPath += handlerName;\n      throw new Error(`Found dependency cycle in trace event handlers: ${stackPath}`);\n    }\n    visited.add(handlerName);\n    const handler = traceHandlers[handlerName];\n    if (!handler) {\n      return;\n    }\n    const deps = handler.deps?.();\n    if (deps) {\n      deps.forEach(visitHandler);\n    }\n    sortedMap.set(handlerName, handler);\n  };\n\n  for (const handlerName of Object.keys(traceHandlers)) {\n    visitHandler(handlerName as Handlers.Types.TraceEventHandlerName);\n  }\n  return sortedMap;\n}\n\nconst enum IteratorItemType {\n  TRACE_EVENT = 1,\n  STATUS_UPDATE = 2,\n}\n\ntype IteratorItem = IteratorTraceEventItem|IteratorStatusUpdateItem;\n\ntype IteratorTraceEventItem = {\n  kind: IteratorItemType.TRACE_EVENT,\n  data: Types.TraceEvents.TraceEventData,\n};\n\ntype IteratorStatusUpdateItem = {\n  kind: IteratorItemType.STATUS_UPDATE,\n  data: TraceParseEventProgressData,\n};\n\nclass TraceEventIterator {\n  #time: number;\n\n  constructor(\n      private traceEvents: readonly Types.TraceEvents.TraceEventData[], private pauseDuration: number,\n      private pauseFrequencyMs: number) {\n    this.#time = performance.now();\n  }\n\n  async * [Symbol.asyncIterator](): AsyncGenerator<IteratorItem, void, void> {\n    for (let i = 0, length = this.traceEvents.length; i < length; i++) {\n      // Every so often we take a break just to render.\n      if (performance.now() - this.#time > this.pauseFrequencyMs) {\n        this.#time = performance.now();\n        // Take the opportunity to provide status update events.\n        yield {kind: IteratorItemType.STATUS_UPDATE, data: {index: i, total: length}};\n        // Wait for rendering before resuming.\n        await new Promise(resolve => setTimeout(resolve, this.pauseDuration));\n      }\n\n      yield {kind: IteratorItemType.TRACE_EVENT, data: this.traceEvents[i]};\n    }\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
