{
  "version": 3,
  "sources": ["../../../../../../../front_end/models/trace/sdk_services/DOMNodeLookup.ts"],
  "sourcesContent": ["// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type * as Handlers from '../handlers/handlers.js';\nimport type * as Protocol from '../../../generated/protocol.js';\nimport * as SDK from '../../../core/sdk/sdk.js';\n\nconst singleNodeCache =\n    new Map<Handlers.Types.TraceParseData, Map<Protocol.DOM.BackendNodeId, SDK.DOMModel.DOMNode|null>>();\nconst batchNodesCache = new Map<\n    Handlers.Types.TraceParseData,\n    Map<Set<Protocol.DOM.BackendNodeId>, Map<Protocol.DOM.BackendNodeId, SDK.DOMModel.DOMNode|null>>>();\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function _TEST_clearCache(): void {\n  singleNodeCache.clear();\n  batchNodesCache.clear();\n}\n\n/**\n * Looks up the DOM Node on the page for the given BackendNodeId. Uses the\n * provided TraceParseData as the cache and will cache the result after the\n * first lookup.\n */\nexport async function forNodeId(\n    modelData: Handlers.Types.TraceParseData, nodeId: Protocol.DOM.BackendNodeId): Promise<SDK.DOMModel.DOMNode|null> {\n  const fromCache = singleNodeCache.get(modelData)?.get(nodeId);\n  if (fromCache !== undefined) {\n    return fromCache;\n  }\n\n  const target = SDK.TargetManager.TargetManager.instance().mainFrameTarget();\n  const domModel = target?.model(SDK.DOMModel.DOMModel);\n  if (!domModel) {\n    return null;\n  }\n\n  const domNodesMap = await domModel.pushNodesByBackendIdsToFrontend(new Set([nodeId]));\n  const result = domNodesMap?.get(nodeId) || null;\n\n  const cacheForModel =\n      singleNodeCache.get(modelData) || new Map<Protocol.DOM.BackendNodeId, SDK.DOMModel.DOMNode|null>();\n  cacheForModel.set(nodeId, result);\n  singleNodeCache.set(modelData, cacheForModel);\n\n  return result;\n}\n\n/**\n * Takes a set of Protocol.DOM.BackendNodeId ids and will return a map of NodeId=>DOMNode.\n * Results are cached based on 1) the provided TraceParseData and 2) the provided set of IDs.\n */\nexport async function forMultipleNodeIds(\n    modelData: Handlers.Types.TraceParseData,\n    nodeIds: Set<Protocol.DOM.BackendNodeId>): Promise<Map<Protocol.DOM.BackendNodeId, SDK.DOMModel.DOMNode|null>> {\n  const fromCache = batchNodesCache.get(modelData)?.get(nodeIds);\n  if (fromCache) {\n    return fromCache;\n  }\n  const target = SDK.TargetManager.TargetManager.instance().mainFrameTarget();\n  const domModel = target?.model(SDK.DOMModel.DOMModel);\n  if (!domModel) {\n    return new Map();\n  }\n\n  const domNodesMap = await domModel.pushNodesByBackendIdsToFrontend(nodeIds) || new Map();\n\n  const cacheForModel = batchNodesCache.get(modelData) ||\n      new Map<Set<Protocol.DOM.BackendNodeId>, Map<Protocol.DOM.BackendNodeId, SDK.DOMModel.DOMNode|null>>();\n  cacheForModel.set(nodeIds, domNodesMap);\n  batchNodesCache.set(modelData, cacheForModel);\n\n  return domNodesMap;\n}\n"],
  "mappings": "AAMA;AAEA,MAAM,kBACF,oBAAI;AACR,MAAM,kBAAkB,oBAAI;AAKrB,mCAAkC;AACvC,kBAAgB;AAChB,kBAAgB;AAAA;AAQlB,gCACI,WAA0C,QAAwE;AACpH,QAAM,YAAY,gBAAgB,IAAI,YAAY,IAAI;AACtD,MAAI,cAAc,QAAW;AAC3B,WAAO;AAAA;AAGT,QAAM,SAAS,IAAI,cAAc,cAAc,WAAW;AAC1D,QAAM,WAAW,QAAQ,MAAM,IAAI,SAAS;AAC5C,MAAI,CAAC,UAAU;AACb,WAAO;AAAA;AAGT,QAAM,cAAc,MAAM,SAAS,gCAAgC,oBAAI,IAAI,CAAC;AAC5E,QAAM,SAAS,aAAa,IAAI,WAAW;AAE3C,QAAM,gBACF,gBAAgB,IAAI,cAAc,oBAAI;AAC1C,gBAAc,IAAI,QAAQ;AAC1B,kBAAgB,IAAI,WAAW;AAE/B,SAAO;AAAA;AAOT,yCACI,WACA,SAA+G;AACjH,QAAM,YAAY,gBAAgB,IAAI,YAAY,IAAI;AACtD,MAAI,WAAW;AACb,WAAO;AAAA;AAET,QAAM,SAAS,IAAI,cAAc,cAAc,WAAW;AAC1D,QAAM,WAAW,QAAQ,MAAM,IAAI,SAAS;AAC5C,MAAI,CAAC,UAAU;AACb,WAAO,oBAAI;AAAA;AAGb,QAAM,cAAc,MAAM,SAAS,gCAAgC,YAAY,oBAAI;AAEnF,QAAM,gBAAgB,gBAAgB,IAAI,cACtC,oBAAI;AACR,gBAAc,IAAI,SAAS;AAC3B,kBAAgB,IAAI,WAAW;AAE/B,SAAO;AAAA;",
  "names": []
}
