{
  "version": 3,
  "sources": ["../../../../../../../front_end/models/trace/handlers/RendererHandler.ts"],
  "sourcesContent": ["// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as Helpers from '../helpers/helpers.js';\n\nimport {data as metaHandlerData} from './MetaHandler.js';\nimport {\n  buildStackTraceAsCallFramesFromId,\n  data as samplesData,\n  getAllHotFunctionsBetweenTimestamps,\n} from './SamplesHandler.js';\n\nimport {KnownEventName, KNOWN_EVENTS, type TraceEventHandlerName, HandlerState} from './types.js';\nimport * as Types from '../types/types.js';\n\nconst processes = new Map<Types.TraceEvents.ProcessID, RendererProcess>();\nconst traceEventToNode = new Map<RendererEvent, RendererEventNode>();\nconst allRendererEvents: RendererEvent[] = [];\n\nlet handlerState = HandlerState.UNINITIALIZED;\n\nconst makeRendererProcess = (): RendererProcess => ({\n  url: null,\n  isOnMainFrame: false,\n  threads: new Map(),\n});\n\nconst makeRendererThread = (): RendererThread => ({\n  name: null,\n  events: [],\n});\n\nconst makeEmptyRendererEventTree = (): RendererEventTree => ({\n  nodes: new Map(),\n  roots: new Set(),\n  maxDepth: 0,\n});\n\nconst makeEmptyRendererEventNode = (eventIndex: number): RendererEventNode => ({\n  eventIndex,\n  parentId: null,\n  childrenIds: new Set(),\n  depth: 0,\n});\n\nconst makeRendererEventNodeIdGenerator = (): () => RendererEventNodeId => {\n  let i = 0;\n  return (): RendererEventNodeId => i++ as RendererEventNodeId;\n};\n\nconst getOrCreateRendererProcess =\n    (processes: Map<Types.TraceEvents.ProcessID, RendererProcess>, pid: Types.TraceEvents.ProcessID):\n        RendererProcess => {\n          return Platform.MapUtilities.getWithDefault(processes, pid, makeRendererProcess);\n        };\n\nconst getOrCreateRendererThread = (process: RendererProcess, tid: Types.TraceEvents.ThreadID): RendererThread => {\n  return Platform.MapUtilities.getWithDefault(process.threads, tid, makeRendererThread);\n};\n\nexport function reset(): void {\n  processes.clear();\n  traceEventToNode.clear();\n  allRendererEvents.length = 0;\n  handlerState = HandlerState.UNINITIALIZED;\n}\n\nexport function initialize(): void {\n  if (handlerState !== HandlerState.UNINITIALIZED) {\n    throw new Error('Renderer Handler was not reset');\n  }\n\n  handlerState = HandlerState.INITIALIZED;\n}\n\nexport function handleEvent(event: Types.TraceEvents.TraceEventData): void {\n  if (handlerState !== HandlerState.INITIALIZED) {\n    throw new Error('Renderer Handler is not initialized');\n  }\n\n  if (Types.TraceEvents.isTraceEventInstant(event) || Types.TraceEvents.isTraceEventComplete(event)) {\n    const process = getOrCreateRendererProcess(processes, event.pid);\n    const thread = getOrCreateRendererThread(process, event.tid);\n    thread.events.push(event);\n    allRendererEvents.push(event);\n  }\n}\n\nexport async function finalize(): Promise<void> {\n  if (handlerState !== HandlerState.INITIALIZED) {\n    throw new Error('Renderer Handler is not initialized');\n  }\n\n  const {mainFrameId, rendererProcessesByFrame, threadsInProcess} = metaHandlerData();\n  assignMeta(processes, mainFrameId, rendererProcessesByFrame, threadsInProcess);\n  sanitizeProcesses(processes);\n  buildHierarchy(processes, {filter: KNOWN_EVENTS});\n  sanitizeThreads(processes);\n\n  handlerState = HandlerState.FINALIZED;\n}\n\nexport function data(): RendererHandlerData {\n  if (handlerState !== HandlerState.FINALIZED) {\n    throw new Error('Renderer Handler is not finalized');\n  }\n\n  return {\n    processes: new Map(processes),\n    traceEventToNode: new Map(traceEventToNode),\n    allRendererEvents: [...allRendererEvents],\n  };\n}\n\n/**\n * Steps through all the renderer processes we've located so far in the meta\n * handler, obtaining their URL, checking whether they are the main frame, and\n * collecting each one of their threads' name. This meta handler's data is\n * assigned to the renderer handler's data.\n */\nexport function assignMeta(\n    processes: Map<Types.TraceEvents.ProcessID, RendererProcess>, mainFrameId: string,\n    rendererProcessesByFrame: Map<string, Map<Types.TraceEvents.ProcessID, {frame: Types.TraceEvents.TraceFrame}>>,\n    threadsInProcess:\n        Map<Types.TraceEvents.ProcessID, Map<Types.TraceEvents.ThreadID, Types.TraceEvents.TraceEventThreadName>>):\n    void {\n  assignOrigin(processes, mainFrameId, rendererProcessesByFrame);\n  assignIsMainFrame(processes, mainFrameId, rendererProcessesByFrame);\n  assignThreadName(processes, rendererProcessesByFrame, threadsInProcess);\n}\n\n/**\n * Assigns origins to all threads in all processes.\n * @see assignMeta\n */\nexport function assignOrigin(\n    processes: Map<Types.TraceEvents.ProcessID, RendererProcess>, mainFrameId: string,\n    rendererProcessesByFrame: Map<string, Map<Types.TraceEvents.ProcessID, {frame: Types.TraceEvents.TraceFrame}>>):\n    void {\n  for (const [frameId, renderProcessesByPid] of rendererProcessesByFrame) {\n    for (const [pid, processInfo] of renderProcessesByPid) {\n      const process = getOrCreateRendererProcess(processes, pid);\n      try {\n        // Sometimes a single process is responsible with rendering multiple\n        // frames at the same time. For example, see https://crbug.com/1334563.\n        // When this happens, we'd still like to assign a single url per process\n        // so: 1) use the first frame rendered by this process as the url source\n        // and 2) if there's a more \"important\" frame found, us its url instead.\n        if (process.url === null /* first frame */ || frameId === mainFrameId /* more important frame */) {\n          process.url = new URL(processInfo.frame.url);\n        }\n      } catch (e) {\n        // Failing to parse the URL isn't a concern, so don't stop for this.\n        // Process' url will stay null, we'll filter out these processes later.\n      }\n    }\n  }\n}\n\n/**\n * Assigns whether or not a thread is the main frame to all threads in all processes.\n * @see assignMeta\n */\nexport function assignIsMainFrame(\n    processes: Map<Types.TraceEvents.ProcessID, RendererProcess>, mainFrameId: string,\n    rendererProcessesByFrame: Map<string, Map<Types.TraceEvents.ProcessID, {frame: Types.TraceEvents.TraceFrame}>>):\n    void {\n  for (const [frameId, renderProcessesByPid] of rendererProcessesByFrame) {\n    for (const [pid] of renderProcessesByPid) {\n      const process = getOrCreateRendererProcess(processes, pid);\n      // We have this go in one direction; once a renderer has been flagged as\n      // being on the main frame, we don't unset it to false if were to show up\n      // in a subframe. Equally, if we already saw this renderer in a subframe,\n      // but it becomes the main frame, the flag would get updated.\n      if (frameId === mainFrameId) {\n        process.isOnMainFrame = true;\n      }\n    }\n  }\n}\n\n/**\n * Assigns the thread name to all threads in all processes.\n * @see assignMeta\n */\nexport function assignThreadName(\n    processes: Map<Types.TraceEvents.ProcessID, RendererProcess>,\n    rendererProcessesByFrame: Map<string, Map<Types.TraceEvents.ProcessID, {frame: Types.TraceEvents.TraceFrame}>>,\n    threadsInProcess:\n        Map<Types.TraceEvents.ProcessID, Map<Types.TraceEvents.ThreadID, Types.TraceEvents.TraceEventThreadName>>):\n    void {\n  for (const [, renderProcessesByPid] of rendererProcessesByFrame) {\n    for (const [pid] of renderProcessesByPid) {\n      const process = getOrCreateRendererProcess(processes, pid);\n      for (const [tid, threadInfo] of threadsInProcess.get(pid) ?? []) {\n        const thread = getOrCreateRendererThread(process, tid);\n        thread.name = threadInfo?.args.name ?? `${tid}`;\n      }\n    }\n  }\n}\n\n/**\n * Removes unneeded trace data opportunistically stored while handling events.\n * This currently does the following:\n *  - Deletes processes with an unkonwn origin.\n */\nexport function sanitizeProcesses(processes: Map<Types.TraceEvents.ProcessID, RendererProcess>): void {\n  for (const [pid, process] of processes) {\n    // If the process had no url, or if it had a malformed url that could not be\n    // parsed for some reason, or if it's an \"about:\" origin, delete it.\n    // This is done because we don't really care about processes for which we\n    // can't provide actionable insights to the user (e.g. about:blank pages).\n    if (process.url === null || process.url.protocol === 'about:') {\n      processes.delete(pid);\n    }\n  }\n}\n\n/**\n * Removes unneeded trace data opportunistically stored while handling events.\n * This currently does the following:\n *  - Deletes threads with no roots.\n */\nexport function sanitizeThreads(processes: Map<Types.TraceEvents.ProcessID, RendererProcess>): void {\n  for (const [, process] of processes) {\n    for (const [tid, thread] of process.threads) {\n      // If the thread has no roots, also delete it. Otherwise, there's going to\n      // be space taken, even though nothing is rendered in the track manager.\n      if (!thread.tree?.roots.size) {\n        process.threads.delete(tid);\n      }\n    }\n  }\n}\n\n/**\n * Creates a hierarchical structure from the trace events. Each thread in each\n * process will contribute to their own individual hierarchy.\n *\n * The trace data comes in as a contiguous array of events, against which we\n * make a couple of assumptions:\n *\n *  1. Events are temporally-ordered in terms of start time (though they're\n *     not necessarily ordered as such in the data stream).\n *  2. If event B's start and end times are within event A's time boundaries\n *     we assume that A is the parent of B.\n *\n * Therefore we expect to reformulate something like:\n *\n * [ Task A ][ Task B ][ Task C ][ Task D ][ Task E ]\n *\n * Into something hierarchically-arranged like below:\n *\n * |------------- Task A -------------||-- Task E --|\n *  |-- Task B --||-- Task D --|\n *   |- Task C -|\n */\nexport function buildHierarchy(\n    processes: Map<Types.TraceEvents.ProcessID, RendererProcess>,\n    options: {filter: {has: (name: KnownEventName) => boolean}}): void {\n  for (const [, process] of processes) {\n    for (const [, thread] of process.threads) {\n      // Step 1. Massage the data.\n      Helpers.Trace.sortTraceEventsInPlace(thread.events);\n      // Step 2. Build the tree.\n      thread.tree = treify(thread.events, options);\n    }\n  }\n}\n\n/**\n * Builds a hierarchy of the trace events in a particular thread of a\n * particular process, assuming that they're sorted, by iterating through all of\n * the events in order.\n *\n * The approach is analogous to how a parser would be implemented. A stack\n * maintains local context. A scanner peeks and pops from the data stream.\n * Various \"tokens\" (events) are treated as \"whitespace\" (ignored).\n *\n * The tree starts out empty and is populated as the hierarchy is built. The\n * nodes are also assumed to be created empty, with no known parent or children.\n *\n * Complexity: O(n), where n = number of events\n */\nexport function treify(\n    events: RendererEvent[], options: {filter: {has: (name: KnownEventName) => boolean}}): RendererEventTree {\n  const stack = [];\n  const tree = makeEmptyRendererEventTree();\n  const makeRendererEventNodeId = makeRendererEventNodeIdGenerator();\n  let lastScheduleStyleRecalcEvent: RendererEvent|null = null;\n  let lastInvalidateLayout: RendererEvent|null = null;\n  let lastForcedStyleRecalc: RendererEvent|null = null;\n\n  for (let i = 0; i < events.length; i++) {\n    const event = events[i];\n\n    buildHotFunctionsStackTracesForTask(event);\n\n    if (event.name === KnownEventName.ScheduleStyleRecalculation) {\n      lastScheduleStyleRecalcEvent = event;\n    }\n    if (event.name === KnownEventName.InvalidateLayout) {\n      lastInvalidateLayout = event;\n    }\n    if (event.name === KnownEventName.RecalculateStyles) {\n      lastForcedStyleRecalc = event;\n    }\n    // If the current event should not be part of the tree, then simply proceed\n    // with the next event.\n    if (!options.filter.has(event.name as KnownEventName)) {\n      continue;\n    }\n\n    const duration = Types.TraceEvents.isTraceEventInstant(event) ? 0 : event.dur;\n\n    // If the parent stack is empty, then the current event is a root. Create a\n    // node for it, mark it as a root, then proceed with the next event.\n    if (stack.length === 0) {\n      const node = makeEmptyRendererEventNode(i);\n      const nodeId = makeRendererEventNodeId();\n      tree.nodes.set(nodeId, node);\n      tree.roots.add(nodeId);\n      event.totalTime = Types.Timing.MicroSeconds(duration);\n      event.selfTime = Types.Timing.MicroSeconds(duration);\n      stack.push(nodeId);\n      tree.maxDepth = Math.max(tree.maxDepth, stack.length);\n      traceEventToNode.set(event, node);\n      continue;\n    }\n\n    const parentNodeId = stack[stack.length - 1];\n    if (parentNodeId === undefined) {\n      throw new Error('Impossible: no parent node id found in the stack');\n    }\n\n    const parentNode = tree.nodes.get(parentNodeId);\n    if (!parentNode) {\n      throw new Error('Impossible: no parent node exists for the given id');\n    }\n\n    const parentEvent = events[parentNode.eventIndex];\n    if (!parentEvent) {\n      throw new Error('Impossible: no parent event exists for the given node');\n    }\n\n    const begin = event.ts;\n    const parentBegin = parentEvent.ts;\n    const parentDuration = Types.TraceEvents.isTraceEventInstant(parentEvent) ? 0 : parentEvent.dur;\n    const end = begin + duration;\n    const parentEnd = parentBegin + parentDuration;\n    // Check the relationship between the parent event at the top of the stack,\n    // and the current event being processed. There are only 4 distinct\n    // possiblities, only 2 of them actually valid, given the assumed sorting:\n    // 1. Current event starts before the parent event, ends whenever. (invalid)\n    // 2. Current event starts after the parent event, ends whenever. (valid)\n    // 3. Current event starts during the parent event, ends after. (invalid)\n    // 4. Current event starts and ends during the parent event. (valid)\n\n    // 1. If the current event starts before the parent event, then the data is\n    //    not sorted properly, messed up some way, or this logic is incomplete.\n    const startsBeforeParent = begin < parentBegin;\n    if (startsBeforeParent) {\n      throw new Error('Impossible: current event starts before the parent event');\n    }\n\n    // 2. If the current event starts after the parent event, then it's a new\n    //    parent. Pop, then handle current event again.\n    const startsAfterParent = begin >= parentEnd;\n    if (startsAfterParent) {\n      stack.pop();\n      i--;\n      continue;\n    }\n\n    // 3. If the current event starts during the parent event, but ends after\n    //    it, then the data is messed up some way.\n    const endsAfterParent = end > parentEnd;\n    if (endsAfterParent) {\n      throw new Error('Impossible: current event starts during the parent event');\n    }\n\n    // 4. The only remaining case is the common case, where the current event is\n    //    contained within the parent event. Create a node for the current\n    //    event, establish the parent/child relationship, then proceed with the\n    //    next event.\n    const node = makeEmptyRendererEventNode(i);\n    const nodeId = makeRendererEventNodeId();\n    tree.nodes.set(nodeId, node);\n    node.depth = stack.length;\n    node.parentId = parentNodeId;\n    parentNode.childrenIds.add(nodeId);\n    event.selfTime = Types.Timing.MicroSeconds(duration);\n    event.totalTime = Types.Timing.MicroSeconds(duration);\n    if (parentEvent.selfTime !== undefined) {\n      parentEvent.selfTime = Types.Timing.MicroSeconds(parentEvent.selfTime - event.totalTime);\n    }\n    stack.push(nodeId);\n    tree.maxDepth = Math.max(tree.maxDepth, stack.length);\n    traceEventToNode.set(event, node);\n    // For checking if an event is a forced layout, this point in the process\n    // is the perfect spot.\n    // An event is a forced layout if it is in a subset of all events (see\n    // EVENTS_THAT_MAY_BE_FORCED_LAYOUTS constant) AND if its parent event is\n    // not a RunTask.  Rather than navigate the tree and perform this check\n    // later on, we can do this at this point, where we already have done the\n    // work to calculate the event and its parent event.\n    checkIfEventIsForcedLayoutAndStore(\n        event, lastScheduleStyleRecalcEvent, lastInvalidateLayout, lastForcedStyleRecalc);\n  }\n  return tree;\n}\n\nfunction checkIfEventIsForcedLayoutAndStore(\n    event: RendererEvent, lastScheduleStyleRecalcEvent: RendererEvent|null, lastInvalidateLayout: RendererEvent|null,\n    lastForcedStyleRecalc: RendererEvent|null): void {\n  // Forced re relayout\n  if (FORCED_LAYOUT_EVENT_NAMES.has(event.name as KnownEventName)) {\n    if (lastInvalidateLayout) {\n      // By default, the initiator of a forced re layout is the last InvalidateLayout event.\n      event.initiator = lastInvalidateLayout;\n    }\n\n    // However if the last InvalidateLayout ended before the last forced styles recalc,\n    // set the initiator to be the last ScheduleStylesRecalc.\n    const lastForcedStyleEndTime = lastForcedStyleRecalc && lastForcedStyleRecalc.ts + (lastForcedStyleRecalc.dur || 0);\n    const hasInitiator = lastScheduleStyleRecalcEvent && lastInvalidateLayout && lastForcedStyleEndTime;\n    if (hasInitiator && lastForcedStyleEndTime > lastInvalidateLayout.ts) {\n      event.initiator = lastScheduleStyleRecalcEvent;\n    }\n  }\n\n  // Forced styles recalc\n  if (FORCED_RECALC_STYLE_EVENTS.has(event.name as KnownEventName)) {\n    lastForcedStyleRecalc = event;\n    if (lastScheduleStyleRecalcEvent) {\n      // By default, the initiator of a forced styles recalc is the last ScheduleStylesRecalc event.\n      event.initiator = lastScheduleStyleRecalcEvent;\n    }\n  }\n}\n\nfunction eventIsLongTask(event: RendererEvent, mustBeOnMainFrame: boolean): boolean {\n  if (event.name !== KnownEventName.RunTask) {\n    return false;\n  }\n  const eventProcess = processes.get(event.pid);\n  const isOnMainFrame = Boolean(eventProcess && eventProcess.isOnMainFrame);\n  if (!isOnMainFrame && mustBeOnMainFrame) {\n    return false;\n  }\n\n  const errorTimeThreshold = Helpers.Timing.millisecondsToMicroseconds(Types.Timing.MilliSeconds(50));\n  const eventDuration = Types.TraceEvents.isTraceEventInstant(event) ? 0 : event.dur;\n  return eventDuration > errorTimeThreshold;\n}\n\nexport function buildHotFunctionsStackTracesForTask(task: RendererEvent): void {\n  if (!eventIsLongTask(task, true)) {\n    // Don't spend time computing this data for tasks that aren't long.\n    return;\n  }\n  const {processes} = samplesData();\n  const thread = processes.get(task.pid)?.threads.get(task.tid);\n  // This threshold is temporarily set to 0 until so that at the moment\n  // we want to always show what functions were executed in a long task.\n  // In the future however, as we provide more sophisticated details\n  // for long tasks, we should set the threshold to a more valuable value.\n  const HOT_FUNCTION_MIN_SELF_PERCENTAGE = 0;\n  const calls = thread?.calls;\n  const taskStart = task.ts;\n  const taskEnd = Types.Timing.MicroSeconds(task.ts + (task.dur || 0));\n  const hotFunctions =\n      calls && getAllHotFunctionsBetweenTimestamps(calls, taskStart, taskEnd, HOT_FUNCTION_MIN_SELF_PERCENTAGE);\n  const tree = thread?.tree;\n  if (!hotFunctions || !tree) {\n    return;\n  }\n  // Store the top 10 hot functions.\n  const MAX_HOT_FUNCTION_COUNT = 10;\n  task.hotFunctionsStackTraces =\n      hotFunctions.slice(0, MAX_HOT_FUNCTION_COUNT)\n          .map(hotFunction => buildStackTraceAsCallFramesFromId(tree, hotFunction.stackFrame.nodeId).reverse());\n}\n\nexport const FORCED_LAYOUT_EVENT_NAMES = new Set([\n  KnownEventName.Layout,\n]);\n\nexport const FORCED_RECALC_STYLE_EVENTS = new Set([\n  KnownEventName.RecalculateStyles,\n  KnownEventName.UpdateLayoutTree,\n]);\n\nexport function deps(): TraceEventHandlerName[] {\n  return ['Meta', 'Samples'];\n}\n\nexport interface RendererHandlerData {\n  processes: Map<Types.TraceEvents.ProcessID, RendererProcess>;\n  traceEventToNode: Map<RendererEvent, RendererEventNode>;\n  allRendererEvents: RendererEvent[];\n}\n\nexport interface RendererProcess {\n  url: URL|null;\n  isOnMainFrame: boolean;\n  threads: Map<Types.TraceEvents.ThreadID, RendererThread>;\n}\n\nexport interface RendererThread {\n  name: string|null;\n  events: RendererEvent[];\n  tree?: RendererEventTree;\n}\n\ninterface RendererEventData {\n  selfTime: Types.Timing.MicroSeconds;\n  totalTime: Types.Timing.MicroSeconds;\n  initiator: RendererEvent;\n  hotFunctionsStackTraces: Types.TraceEvents.TraceEventCallFrame[][];\n}\n\nexport type RendererEvent = Types.TraceEvents.TraceEventRendererData&Partial<RendererEventData>;\n\nexport interface RendererEventTree {\n  nodes: Map<RendererEventNodeId, RendererEventNode>;\n  roots: Set<RendererEventNodeId>;\n  maxDepth: number;\n}\n\nexport interface RendererEventNode {\n  eventIndex: number;\n  depth: number;\n  parentId?: RendererEventNodeId|null;\n  childrenIds: Set<RendererEventNodeId>;\n}\n\nclass RendererEventNodeIdTag {\n  /* eslint-disable-next-line no-unused-private-class-members */\n  readonly #tag: (symbol|undefined);\n}\nexport type RendererEventNodeId = number&RendererEventNodeIdTag;\n"],
  "mappings": "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",
  "names": []
}
