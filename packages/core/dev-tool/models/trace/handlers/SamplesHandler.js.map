{
  "version": 3,
  "sources": ["../../../../../../../front_end/models/trace/handlers/SamplesHandler.ts"],
  "sourcesContent": ["// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as Helpers from '../helpers/helpers.js';\nimport * as Types from '../types/types.js';\n\nimport {HandlerState, EventCategory, KNOWN_EVENTS, type KnownEventName} from './types.js';\n\n/**\n * Sorts samples in place, in order, by their start time.\n */\nexport function sortProfileSamples(samples: ProfileSample[]): void {\n  samples.sort((a, b) => {\n    const aBeginTime = a.ts;\n    const bBeginTime = b.ts;\n    if (aBeginTime < bBeginTime) {\n      return -1;\n    }\n    if (aBeginTime > bBeginTime) {\n      return 1;\n    }\n    return 0;\n  });\n}\n\nconst KNOWN_BOUNDARIES = new Set([\n  EventCategory.Other,\n  EventCategory.V8,\n  EventCategory.Js,\n  EventCategory.Gc,\n]);\n\nconst ALLOWED_CALL_FRAME_CODE_TYPES = new Set([undefined, 'JS']);\nconst BANNED_CALL_FRAME_URL_REGS = [/^chrome-extension:\\/\\//, /^extensions::/];\n\nconst SAMPLING_INTERVAL = Types.Timing.MicroSeconds(200);\n\nconst events =\n    new Map<Types.TraceEvents.ProcessID, Map<Types.TraceEvents.ThreadID, Types.TraceEvents.TraceEventComplete[]>>();\nconst profiles = new Map<Types.TraceEvents.ProfileID, Partial<SamplesProfile>>();\nconst processes = new Map<Types.TraceEvents.ProcessID, SamplesProcess>();\n\nlet handlerState = HandlerState.UNINITIALIZED;\n\nconst makeSamplesProcess = (): SamplesProcess => ({\n  threads: new Map(),\n});\n\nconst makeSamplesThread = (profile: SamplesProfile): SamplesThread => ({\n  profile,\n});\n\nconst makeEmptyProfileTree = (): ProfileTree => ({\n  nodes: new Map(),\n});\n\nconst makeEmptyProfileNode = (callFrame: Types.TraceEvents.TraceEventCallFrame): ProfileNode => ({\n  callFrame,\n  parentId: null,\n  childrenIds: new Set(),\n});\n\nconst makeProfileSample =\n    (nodeId: Types.TraceEvents.CallFrameID, pid: Types.TraceEvents.ProcessID, tid: Types.TraceEvents.ThreadID,\n     ts: Types.Timing.MicroSeconds): ProfileSample => ({\n      topmostStackFrame: {nodeId},\n      tid,\n      pid,\n      ts,\n    });\n\nconst makeProfileCall = (nodeId: Types.TraceEvents.CallFrameID, sample: ProfileSample): ProfileCall => ({\n  stackFrame: {nodeId},\n  tid: sample.tid,\n  pid: sample.pid,\n  ts: sample.ts,\n  dur: Types.Timing.MicroSeconds(0),\n  selfDur: Types.Timing.MicroSeconds(0),\n  children: [],\n});\n\nconst makeEmptyProfileFunction = (nodeId: Types.TraceEvents.CallFrameID): ProfileFunction => ({\n  stackFrame: {nodeId},\n  calls: [],\n  durPercent: 0,\n  selfDurPercent: 0,\n});\n\nconst getOrCreateSamplesProcess =\n    (processes: Map<Types.TraceEvents.ProcessID, SamplesProcess>, pid: Types.TraceEvents.ProcessID): SamplesProcess => {\n      return Platform.MapUtilities.getWithDefault(processes, pid, makeSamplesProcess);\n    };\n\nconst getOrCreateSamplesThread =\n    (process: SamplesProcess, tid: Types.TraceEvents.ThreadID, profile: SamplesProfile): SamplesThread => {\n      return Platform.MapUtilities.getWithDefault(process.threads, tid, () => makeSamplesThread(profile));\n    };\n\nexport function reset(): void {\n  events.clear();\n  profiles.clear();\n  processes.clear();\n\n  handlerState = HandlerState.UNINITIALIZED;\n}\n\nexport function initialize(): void {\n  if (handlerState !== HandlerState.UNINITIALIZED) {\n    throw new Error('Samples Handler was not reset');\n  }\n\n  handlerState = HandlerState.INITIALIZED;\n}\n\nexport function handleEvent(event: Types.TraceEvents.TraceEventData): void {\n  if (handlerState !== HandlerState.INITIALIZED) {\n    throw new Error('Samples Handler is not initialized');\n  }\n\n  if (Types.TraceEvents.isTraceEventProfile(event)) {\n    const profile = Platform.MapUtilities.getWithDefault(profiles, event.id, (): Partial<SamplesProfile> => ({}));\n    profile.head = event;\n    return;\n  }\n  if (Types.TraceEvents.isTraceEventProfileChunk(event)) {\n    const profile = Platform.MapUtilities.getWithDefault(profiles, event.id, (): Partial<SamplesProfile> => ({}));\n    profile.chunks = profile.chunks ?? [];\n    profile.chunks.push(event);\n    return;\n  }\n  if (Types.TraceEvents.isTraceEventComplete(event)) {\n    const process = Platform.MapUtilities.getWithDefault(events, event.pid, () => new Map());\n    const thread = Platform.MapUtilities.getWithDefault(process, event.tid, () => []);\n    thread.push(event);\n    return;\n  }\n}\n\nexport async function finalize(): Promise<void> {\n  if (handlerState !== HandlerState.INITIALIZED) {\n    throw new Error('Samples Handler is not initialized');\n  }\n  buildProcessesAndThreads(profiles, processes);\n  buildHierarchy(processes, events);\n\n  handlerState = HandlerState.FINALIZED;\n}\n\nexport function data(): SamplesHandlerData {\n  if (handlerState !== HandlerState.FINALIZED) {\n    throw new Error('Samples Handler is not finalized');\n  }\n\n  return {\n    profiles: new Map(profiles),\n    processes: new Map(processes),\n  };\n}\n\n/**\n * Builds processes and threads from the accumulated profile chunks. This is\n * done during finalize instead of during event handling because profile heads\n * and chunks are sometimes retrieved out of order, or are incomplete.\n */\nexport function buildProcessesAndThreads(\n    profiles: Map<Types.TraceEvents.ProfileID, Partial<SamplesProfile>>,\n    processes: Map<Types.TraceEvents.ProcessID, SamplesProcess>): void {\n  for (const [, profile] of profiles) {\n    // Sometimes the trace includes empty profiles, or orphaned chunks, even\n    // after going through all the trace events. Ignore.\n    const {head, chunks} = profile;\n    if (!head || !chunks?.length) {\n      continue;\n    }\n\n    // Note: events are collected on a different thread than what's sampled.\n    // The correct process and thread ids are specified by the profile.\n    const pid = head.pid;\n    const tid = head.tid;\n    getOrCreateSamplesThread(getOrCreateSamplesProcess(processes, pid), tid, profile as SamplesProfile);\n  }\n}\n\n/**\n * Converts the raw profile data into hierarchical and ordered structures from\n * the stack traces that were sampled during a recording. Each thread in each\n * process will contribute to their own individual profile.\n *\n * Our V8 profiler is a sampling profiler. This means that it probes the\n * program's call stack at regular intervals defined by the sampling frequency.\n * The raw profile data comes in as multiple events, from which a profile is\n * built.\n *\n * The generated data will be comprised of several parts:\n * 1. \"tree\": All the complete stack traces, represented by a tree whose roots\n *    are the bottomest stack frames of all stack traces.\n * 2. \"samples\": All the individual samples, as an ordered list where each item\n *    points to the topmost stack frame at a particular point in time.\n * 3. \"calls\": A list of profile calls, where each item represents multiple\n *    samples coalesced into a contiguous event. Each item will have a\n *    timestamp, duration, and refer to a stack frame and its child frames\n *    (all together forming multiple stack traces).\n */\nexport function buildHierarchy(\n    processes: Map<Types.TraceEvents.ProcessID, SamplesProcess>,\n    events: Map<Types.TraceEvents.ProcessID, Map<Types.TraceEvents.ThreadID, Types.TraceEvents.TraceEventComplete[]>>):\n    void {\n  for (const [pid, process] of processes) {\n    for (const [tid, thread] of process.threads) {\n      // Step 1. Massage the data.\n      Helpers.Trace.sortTraceEventsInPlace(thread.profile.chunks);\n      // ...and collect boundaries.\n      const boundariesOptions = {filter: KNOWN_BOUNDARIES};\n      const boundaries = thread.boundaries = collectBoundaries(events, pid, tid, boundariesOptions);\n\n      // Step 2. Collect all the complete stack traces into a tree.\n      const tree = thread.tree = collectStackTraces(thread.profile.chunks);\n\n      // Step 3. Collect all the individual samples into a list.\n      const {startTime} = thread.profile.head.args.data;\n      const samplesOptions = {filterCodeTypes: true, filterUrls: true};\n      const samples = thread.samples = collectSamples(pid, tid, startTime, tree, thread.profile.chunks, samplesOptions);\n\n      // Step 4. Coalesce samples.\n      const merge = mergeCalls(samples.map(sample => buildProfileCallFromSample(tree, sample)), boundaries);\n      thread.calls = merge.calls;\n      thread.dur = merge.dur;\n    }\n  }\n}\n\n/**\n * Builds an array of timestamps corresponding to the begin and end boundaries\n * of the events on the specified process and thread.\n *\n * Therefore we expect to reformulate a set of events which can be represented\n * hierarchically like:\n *\n * |=========== Task A ===============|== Task E ==|\n *   |=== Task B ===|== Task D ==|\n *     |= Task C =|\n *\n * ...into something ordered like below:\n *\n * | | |          | |                 |            |\n * |=========== Task A ===============|== Task E ==|\n * | |=== Task B ===|== Task D ==|    |            |\n * | | |= Task C =| |            |    |            |\n * | | |          | |            |    |            |\n * X X X          X X            X    X            X (boundaries)\n */\nexport function collectBoundaries(\n    events: Map<Types.TraceEvents.ProcessID, Map<Types.TraceEvents.ThreadID, Types.TraceEvents.TraceEventComplete[]>>,\n    pid: Types.TraceEvents.ProcessID, tid: Types.TraceEvents.ThreadID,\n    options: {filter: {has: (category: EventCategory) => boolean}}): Types.Timing.MicroSeconds[] {\n  const process = events.get(pid);\n  if (!process) {\n    return [];\n  }\n\n  const thread = process.get(tid);\n  if (!thread) {\n    return [];\n  }\n\n  const boundaries = new Set<Types.Timing.MicroSeconds>();\n\n  for (const event of thread) {\n    const category = KNOWN_EVENTS.get(event.name as KnownEventName)?.category ?? EventCategory.Other;\n    if (!options.filter.has(category)) {\n      continue;\n    }\n    boundaries.add(event.ts);\n    boundaries.add(Types.Timing.MicroSeconds(event.ts + event.dur));\n  }\n\n  return [...boundaries].sort((a, b) => a < b ? -1 : 1);\n}\n\n/**\n * Builds all the complete stack traces that exist in a particular thread of a\n * particular process. They will be stored as a tree. The roots of this tree are\n * the bottomest stack frames of all individual stack traces.\n *\n * The stack traces are retrieved in partial chains, each chain as part of a\n * trace event. This method collects the data into a single tree.\n *\n * Therefore we expect to reformulate something like:\n *\n * Chain 1: [A, B <- A, C <- B]\n * Chain 2: [D <- A, E <- D]\n * Chain 3: [G]\n * Chain 4: [F <- B]\n * Chain 5: [H <- G, I <- H]\n *\n * ...into something hierarchically-arranged like below:\n *\n *     A       G\n *    / \\      |\n *   B   D     H\n *  / \\   \\    |\n * C   F   E   I\n */\nexport function collectStackTraces(\n    chunks: Types.TraceEvents.TraceEventProfileChunk[],\n    options?: {filterCodeTypes: boolean, filterUrls: boolean}): ProfileTree {\n  const tree = makeEmptyProfileTree();\n\n  for (const chunk of chunks) {\n    const cpuProfile = chunk.args.data.cpuProfile;\n    if (!cpuProfile) {\n      continue;\n    }\n    const chain = cpuProfile.nodes;\n    if (!chain) {\n      continue;\n    }\n\n    for (const link of chain) {\n      const nodeId = link.id;\n      const parentNodeId = link.parent;\n      const callFrame = link.callFrame;\n\n      // If the current call frame should not be part of the tree, then simply proceed\n      // with the next call frame.\n      if (!isAllowedCallFrame(callFrame, options)) {\n        continue;\n      }\n\n      const node = Platform.MapUtilities.getWithDefault(tree.nodes, nodeId, () => makeEmptyProfileNode(callFrame));\n\n      // If the call frame has no parent, then it's the bottomest stack frame of\n      // a stack trace (aka a root).\n      if (parentNodeId === undefined) {\n        continue;\n      }\n\n      // Otherwise, this call frame has a parent and threfore it's a stack frame\n      // part of a larger stack trace. Each stack frame can only have a single\n      // parent (called into by another unique stack frame), with multiple\n      // children (calling into multiple unique stack frames). If a codepoint is\n      // reached in multiple ways, multiple stack traces are created by V8.\n      node.parentId = parentNodeId;\n      tree.nodes.get(parentNodeId)?.childrenIds.add(nodeId);\n    }\n  }\n\n  return tree;\n}\n\n/**\n * Collects all the individual samples that exist in a particular thread of a\n * particular process. They will be stored as an ordered list. Each entry\n * represents a sampled stack trace by pointing to the topmost stack frame at\n * that particular time.\n *\n * The samples are retrieved in buckets, each bucket as part of a trace event,\n * and each sample at a positive or negative delta cumulatively relative to the\n * profile's start time. This method collects the data into a single list.\n *\n * Therefore we expect to reformulate something like:\n *\n * Event 1 at 0\u00B5s: [A at \u0394+1\u00B5s, A at \u0394+2\u00B5s, B at \u0394-1\u00B5s, C at \u0394+2\u00B5s]\n * Event 2 at 9\u00B5s: [A at \u0394+1\u00B5s, D at \u0394+9\u00B5s, E at \u0394-1\u00B5s]\n *\n * ...where each sample in each event points to the tompost stack frame at that\n * particular point in time (e.g. the first sample's tompost stack frame is A),\n * into something ordered like below:\n *\n * [A at 1\u00B5s, B at 2\u00B5s, A at 3\u00B5s, C at 4\u00B5s, A at 10\u00B5s, E at 18\u00B5s, D at 19\u00B5s]\n *\n * ...where each sample has an absolute timestamp, and the list is ordered.\n */\nexport function collectSamples(\n    pid: Types.TraceEvents.ProcessID, tid: Types.TraceEvents.ThreadID, ts: Types.Timing.MicroSeconds, tree: ProfileTree,\n    chunks: Types.TraceEvents.TraceEventProfileChunk[],\n    options?: {filterCodeTypes: boolean, filterUrls: boolean}): ProfileSample[] {\n  const samples: ProfileSample[] = [];\n\n  for (const chunk of chunks) {\n    const {timeDeltas, cpuProfile} = chunk.args.data;\n    if (!timeDeltas || !cpuProfile) {\n      continue;\n    }\n\n    for (let i = 0; i < timeDeltas.length; i++) {\n      const timeDelta = timeDeltas[i];\n      const nodeId = cpuProfile.samples[i];\n      // The timestamp of each sample is at a positive or negative delta,\n      // cumulatively relative to the profile's start time.\n      ts = Types.Timing.MicroSeconds(ts + timeDelta);\n\n      // The call frame may not have been added to the stack traces tree (e.g.\n      // if its code type or url was banned). If there is no allowed stack frame\n      // as part of a stack trace, then this sample is dropped.\n      const topmostAllowedNodeId = findTopmostAllowedCallFrame(nodeId, tree, options);\n      if (topmostAllowedNodeId === null) {\n        continue;\n      }\n\n      // Otherwise, push the topmost allowed stack frame.\n      samples.push(makeProfileSample(topmostAllowedNodeId, pid, tid, ts));\n    }\n  }\n\n  sortProfileSamples(samples);\n  return samples;\n}\n\n/**\n * For a list of samples in a thread in a process, merges together stack frames\n * which have been sampled consecutively and which do not cross boundaries. The\n * samples and boundaries arrays are assumed to be sorted.\n *\n * Therefore, if the previously collected stack traces tree looks like this:\n *\n *   A   E\n *  / \\\n * B   D\n * |\n * C\n *\n * ...we expect to reformulate something like:\n *\n * [A, B, C, C .. C, B, A, A .. A, D, D .. D, A, A .. A, E, E .. E]\n *\n * ...where each sample points to the tompost stack frame at that particular\n * point in time (e.g. the first sample's tompost stack frame is A, the last\n * sample's topmost stack frame is E, etc.), and thus the expanded samples array\n * can be represented as:\n *\n * +------------> (sample at time)\n * |\n * |A|A|A|A|A|A|A|A|A|A|A|A|A|A|A|A|A| |E|E|E|E|E|E|\n * | |B|B|B|B|B|B| |D|D|D|D|D|D| | | | | | | | | | |\n * | | |C|C|C|C| | | | | | | | | | | | | | | | | | |\n * |\n * V (stack trace depth)\n *\n * ...into something ordered like below:\n *\n * [ Call A ][ Call E ]\n *\n * ...where the hierarchy of these calls can be represented as:\n *\n * [-------- Call A --------][ Call E ]\n *  [- Call B -][- Call D -]\n *   [ Call C ]\n *\n * ...and where each call has an absolute timestamp and a duration.\n *\n * Considerations:\n *\n * 1. Consecutive stack frames which cross boundaries may not be coalesced.\n * \"Boundaries\" are an array of timestamps corresponding to the begin and end\n * of certain events (such as \"RunTask\").\n *\n * For example, we expect to reformulate something like:\n *\n *   (boundary)                                    (boundary)\n *       |                                             |\n * |A|A|A|A|A|A|A|A|A|A|A|A|A|A|A|A|A| |E|E|E|E|E|E|   |\n *       |                                             |\n *\n * ...into something ordered like below:\n *\n * [ Call A ][ Call A ][ Call E ]\n *\n * ... where the first Call A is before the first boundary, second Call A is\n * after the first boundary, and Call E is inbetween boundaries.\n *\n * 2. Consecutive stack frames which are part of different branches (a.k.a part\n * of a different stack trace) must not be coalesced, even if at the same depth.\n *\n * For example, with something like:\n *\n * +------------> (sample at time)\n * |\n * | ... |X|X|X|Z|Z|Z| ...\n * |         |Y|Y|\n * |\n * V (stack trace depth)\n *\n * ...or:\n *\n * +------------> (sample at time)\n * |\n * | ... |X|X|X|Z|X|X|X| ...\n * |         |Y| |Y|\n * |\n * V (stack trace depth)\n *\n * ...the Y stack frames must not be merged even if they have been sampled\n * close together, and even if they do not cross any boundaries (e.g. are part\n * of the same `RunTask`). This is because they are either:\n * - part of separate stack traces (and therefore would have different IDs), or\n * - separated by a different parent frame.\n */\nexport function mergeCalls(calls: ProfileCall[], boundaries: Types.Timing.MicroSeconds[]): {\n  calls: ProfileCall[],\n  dur: Types.Timing.MicroSeconds,\n} {\n  const out = {calls: new Array<ProfileCall>(), dur: Types.Timing.MicroSeconds(0)};\n  let boundary = 0;\n\n  for (const call of calls) {\n    // When the call crosses a boundary defined by any of the relevant trace\n    // events (e.g. `RunTask`), even if the stack frame would be the same, start\n    // a new merge with the current call as head, and find the next boundary.\n    const isAcrossBoundary = call.ts >= boundary;\n    if (isAcrossBoundary) {\n      const index = Platform.ArrayUtilities.nearestIndexFromBeginning(boundaries, ts => ts > call.ts) ?? Infinity;\n      boundary = boundaries[index];\n      out.calls.push(call);\n      continue;\n    }\n\n    // Otherwise, start a new merge if the call is a different stack frame, or\n    // it was sampled too far into the future from the previous call.\n    const previous = out.calls[out.calls.length - 1];\n    const isSameStackFrame = call.stackFrame.nodeId === previous.stackFrame.nodeId;\n    const isSampledConsecutively = call.ts - (previous.ts + previous.dur) < SAMPLING_INTERVAL;\n    if (!isSameStackFrame || !isSampledConsecutively) {\n      out.calls.push(call);\n      continue;\n    }\n\n    previous.dur = Types.Timing.MicroSeconds(call.ts - previous.ts);\n    previous.children.push(...call.children);\n  }\n\n  for (const call of out.calls) {\n    const merge = mergeCalls(call.children, boundaries);\n    call.children = merge.calls;\n    call.selfDur = Types.Timing.MicroSeconds(call.dur - merge.dur);\n    out.dur = Types.Timing.MicroSeconds(out.dur + call.dur);\n  }\n\n  return out;\n}\n\n/**\n * Checks if the call frame is allowed (i.e. it may not be part of the collected\n * stack traces tree).\n */\nexport function isAllowedCallFrame(\n    callFrame: Types.TraceEvents.TraceEventCallFrame,\n    options?: {filterCodeTypes: boolean, filterUrls: boolean}): boolean {\n  if (options?.filterCodeTypes && !ALLOWED_CALL_FRAME_CODE_TYPES.has(callFrame.codeType)) {\n    return false;\n  }\n  if (options?.filterUrls && BANNED_CALL_FRAME_URL_REGS.some(re => callFrame.url?.match(re))) {\n    return false;\n  }\n  return true;\n}\n\n/**\n * Walks the stack traces tree until it finds a call frame that is allowed.\n */\nexport function findTopmostAllowedCallFrame(\n    nodeId: Types.TraceEvents.CallFrameID|null, tree: ProfileTree,\n    options?: {filterCodeTypes: boolean, filterUrls: boolean}): Types.TraceEvents.CallFrameID|null {\n  if (nodeId === null) {\n    return null;\n  }\n  const node = tree.nodes.get(nodeId);\n  const callFrame = node?.callFrame;\n  if (!node || !callFrame) {\n    return null;\n  }\n  if (!isAllowedCallFrame(callFrame, options)) {\n    return findTopmostAllowedCallFrame(node.parentId, tree, options);\n  }\n  return nodeId;\n}\n\n/**\n * Gets the stack trace associated with a sample. The topmost stack frame will\n * be the last entry of array. Aka the root stack frame will be the first.\n *\n * All the complete stack traces are stored as part of a profile tree. All the\n * samples point to the topmost stack frame. This method walks up the tree to\n * compose a stack trace.\n */\nexport function buildStackTraceAsCallFrameIdsFromId(\n    tree: ProfileTree, nodeId: Types.TraceEvents.CallFrameID): Types.TraceEvents.CallFrameID[] {\n  const out = [];\n\n  let currentNodeId: Types.TraceEvents.CallFrameID|null = nodeId;\n  let currentNode;\n\n  while (currentNodeId !== null && (currentNode = tree.nodes.get(currentNodeId))) {\n    out.push(currentNodeId);\n    currentNodeId = currentNode.parentId;\n  }\n\n  return out.reverse();\n}\n\n/**\n * Just like `buildStackTrace`, but returns an array of call frames instead of ids.\n */\nexport function buildStackTraceAsCallFramesFromId(\n    tree: ProfileTree, nodeId: Types.TraceEvents.CallFrameID): Types.TraceEvents.TraceEventCallFrame[] {\n  const trace = buildStackTraceAsCallFrameIdsFromId(tree, nodeId);\n  return trace.map(nodeId => {\n    const callFrame = tree.nodes.get(nodeId)?.callFrame;\n    if (!callFrame) {\n      throw new Error();\n    }\n    return callFrame;\n  });\n}\n\n/**\n * Just like `buildStackTrace`, but returns a `ProfileCall` instead of an array.\n */\nexport function buildProfileCallFromSample(tree: ProfileTree, sample: ProfileSample): ProfileCall {\n  const trace = buildStackTraceAsCallFrameIdsFromId(tree, sample.topmostStackFrame.nodeId);\n  const calls = trace.map(nodeId => makeProfileCall(nodeId, sample));\n\n  for (let i = 1; i < calls.length; i++) {\n    const parent = calls[i - 1];\n    const current = calls[i];\n    parent.children.push(current);\n  }\n\n  return calls[0];\n}\n\n/**\n * Gets all functions that have been called between the given timestamps, each\n * with additional information:\n * - the call frame id, which points to a node containing the function name etc.\n * - all individual calls for that function\n * - percentage of time taken, relative to the given timestamps\n * - percentage of self time taken relative to the given timestamps\n */\nexport function getAllFunctionsBetweenTimestamps(\n    calls: ProfileCall[], begin: Types.Timing.MicroSeconds, end: Types.Timing.MicroSeconds,\n    out: Map<Types.TraceEvents.CallFrameID, ProfileFunction> = new Map()): IterableIterator<ProfileFunction> {\n  for (const call of calls) {\n    if (call.ts < begin || call.ts + call.dur > end) {\n      continue;\n    }\n    const func = Platform.MapUtilities.getWithDefault(\n        out, call.stackFrame.nodeId, () => makeEmptyProfileFunction(call.stackFrame.nodeId));\n    func.calls.push(call);\n    func.durPercent += (call.dur / (end - begin)) * 100;\n    func.selfDurPercent += (call.selfDur / (end - begin)) * 100;\n    getAllFunctionsBetweenTimestamps(call.children, begin, end, out);\n  }\n\n  return out.values();\n}\n\n/**\n * Gets all the hot functions between timestamps, each with information about\n * the relevant call frame, time, self time, and percentages.\n *\n * The hot functions are sorted by self time.\n */\nexport function getAllHotFunctionsBetweenTimestamps(\n    calls: ProfileCall[], begin: Types.Timing.MicroSeconds, end: Types.Timing.MicroSeconds,\n    minSelfPercent: number): ProfileFunction[] {\n  const functions = getAllFunctionsBetweenTimestamps(calls, begin, end);\n  const hot = [...functions].filter(info => info.selfDurPercent >= minSelfPercent);\n  return hot.sort((a, b) => a.selfDurPercent > b.selfDurPercent ? -1 : 1);\n}\n\nexport interface SamplesHandlerData {\n  profiles: Map<Types.TraceEvents.ProfileID, Partial<SamplesProfile>>;\n  processes: Map<Types.TraceEvents.ProcessID, SamplesProcess>;\n}\n\nexport interface SamplesProfile {\n  head: Types.TraceEvents.TraceEventProfile;\n  chunks: Types.TraceEvents.TraceEventProfileChunk[];\n}\n\nexport interface SamplesProcess {\n  threads: Map<Types.TraceEvents.ThreadID, SamplesThread>;\n}\n\nexport interface SamplesThread {\n  profile: SamplesProfile;\n  boundaries?: Types.Timing.MicroSeconds[];\n  tree?: ProfileTree;\n  samples?: ProfileSample[];\n  calls?: ProfileCall[];\n  dur?: Types.Timing.MicroSeconds;\n}\n\nexport interface ProfileTree {\n  nodes: Map<Types.TraceEvents.CallFrameID, ProfileNode>;\n}\n\nexport interface ProfileNode {\n  callFrame: Types.TraceEvents.TraceEventCallFrame;\n  parentId: Types.TraceEvents.CallFrameID|null;\n  childrenIds: Set<Types.TraceEvents.CallFrameID>;\n}\n\nexport interface ProfileSample {\n  topmostStackFrame: {\n    nodeId: Types.TraceEvents.CallFrameID,\n  };\n  pid: Types.TraceEvents.ProcessID;\n  tid: Types.TraceEvents.ThreadID;\n  ts: Types.Timing.MicroSeconds;\n}\n\nexport interface ProfileCall {\n  stackFrame: {\n    nodeId: Types.TraceEvents.CallFrameID,\n  };\n  pid: Types.TraceEvents.ProcessID;\n  tid: Types.TraceEvents.ThreadID;\n  ts: Types.Timing.MicroSeconds;\n  dur: Types.Timing.MicroSeconds;      // \"time\"\n  selfDur: Types.Timing.MicroSeconds;  // \"self time\"\n  children: ProfileCall[];\n}\n\nexport interface ProfileFunction {\n  stackFrame: {\n    nodeId: Types.TraceEvents.CallFrameID,\n  };\n  calls: ProfileCall[];\n  durPercent: number;      // 0 - 100\n  selfDurPercent: number;  // 0 - 100\n}\n"],
  "mappings": "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",
  "names": []
}
