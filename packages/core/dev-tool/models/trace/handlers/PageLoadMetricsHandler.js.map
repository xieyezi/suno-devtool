{
  "version": 3,
  "sources": ["../../../../../../../front_end/models/trace/handlers/PageLoadMetricsHandler.ts"],
  "sourcesContent": ["// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport type * as Protocol from '../../../generated/protocol.js';\n\nimport * as Helpers from '../helpers/helpers.js';\nimport {KnownEventName, type TraceEventHandlerName, type HandlerData, type Handlers} from './types.js';\n\nimport * as Types from '../types/types.js';\n\nimport {data as metaHandlerData} from './MetaHandler.js';\nimport {data as rendererHandlerData} from './RendererHandler.js';\n\n/**\n * This represents the metric scores for all navigations, for all frames in a trace.\n * Given a frame id, the map points to another map from navigation id to metric scores.\n * The metric scores include the event related to the metric as well as the data regarding\n * the score itself.\n */\nconst metricScoresByFrameId = new Map<string, Map<string, Map<MetricName, MetricScore>>>();\n\nexport function reset(): void {\n  metricScoresByFrameId.clear();\n  pageLoadEventsArray = [];\n  selectedLCPCandidateEvents.clear();\n}\n\nlet pageLoadEventsArray: Types.TraceEvents.PageLoadEvent[] = [];\n\n// Once we've found the LCP events in the trace we want to fetch their DOM Node\n// from the backend. We could do this by parsing through our Map of frame =>\n// navigation => metric, but it's easier to keep a set of LCP events. As we\n// parse the trace, any time we store an LCP candidate as the potential LCP\n// event, we store the event here. If we later find a new candidate in the\n// trace, we store that and delete the prior event. When we've parsed the\n// entire trace this set will contain all the LCP events that were used - e.g.\n// the candidates that were the actual LCP events.\nconst selectedLCPCandidateEvents = new Set<Types.TraceEvents.TraceEventLargestContentfulPaintCandidate>();\n\nfunction eventIsPageLoadEvent(event: Types.TraceEvents.TraceEventData): event is Types.TraceEvents.PageLoadEvent {\n  return Types.TraceEvents.isTraceEventFirstContentfulPaint(event) ||\n      Types.TraceEvents.isTraceEventMarkDOMContent(event) || Types.TraceEvents.isTraceEventInteractiveTime(event) ||\n      Types.TraceEvents.isTraceEventLargestContentfulPaintCandidate(event);\n}\n\nexport function handleEvent(event: Types.TraceEvents.TraceEventData): void {\n  if (!eventIsPageLoadEvent(event)) {\n    return;\n  }\n  pageLoadEventsArray.push(event);\n}\n\nfunction storePageLoadMetricAgainstNavigationId(\n    navigation: Types.TraceEvents.TraceEventNavigationStart, event: Types.TraceEvents.PageLoadEvent): void {\n  const navigationId = navigation.args.data?.navigationId;\n  if (!navigationId) {\n    throw new Error('Navigation event unexpectedly had no navigation ID.');\n  }\n  const frameId = getFrameIdForPageLoadEvent(event);\n  const {rendererProcessesByFrame} = metaHandlerData();\n  const processData = rendererProcessesByFrame.get(frameId)?.get(event.pid);\n  if (!processData) {\n    throw new Error('No processes found for page load event.');\n  }\n\n  // We compare the timestamp of the event to determine if it happened during the\n  // time window in which its process was considered active.\n  const eventBelongsToProcess = event.ts >= processData.window.min && event.ts <= processData.window.max;\n\n  if (!eventBelongsToProcess) {\n    // If the event occurred outside its process' active time window we ignore it.\n    return;\n  }\n\n  if (Types.TraceEvents.isTraceEventFirstContentfulPaint(event)) {\n    const fcpTime = Types.Timing.MicroSeconds(event.ts - navigation.ts);\n    const score = Helpers.Timing.formatMicrosecondsTime(fcpTime, {\n      format: Types.Timing.TimeUnit.SECONDS,\n      maximumFractionDigits: 2,\n    });\n    const classification = scoreClassificationForFirstContentfulPaint(fcpTime);\n    const metricScore = {event, score, metricName: MetricName.FCP, classification, navigation};\n    storeMetricScore(frameId, navigationId, metricScore);\n    return;\n  }\n\n  if (Types.TraceEvents.isTraceEventMarkDOMContent(event)) {\n    const dclTime = Types.Timing.MicroSeconds(event.ts - navigation.ts);\n    const score = Helpers.Timing.formatMicrosecondsTime(dclTime, {\n      format: Types.Timing.TimeUnit.SECONDS,\n      maximumFractionDigits: 2,\n    });\n    const metricScore = {\n      event,\n      score,\n      metricName: MetricName.DCL,\n      classification: scoreClassificationForDOMContentLoaded(dclTime),\n      navigation,\n    };\n    storeMetricScore(frameId, navigationId, metricScore);\n    return;\n  }\n\n  if (Types.TraceEvents.isTraceEventInteractiveTime(event)) {\n    const ttiValue = Types.Timing.MicroSeconds(event.ts - navigation.ts);\n    const ttiScore = Helpers.Timing.formatMicrosecondsTime(ttiValue, {\n      format: Types.Timing.TimeUnit.SECONDS,\n      maximumFractionDigits: 2,\n    });\n    const tti = {\n      event,\n      score: ttiScore,\n      metricName: MetricName.TTI,\n      classification: scoreClassificationForTimeToInteractive(ttiValue),\n      navigation,\n    };\n    storeMetricScore(frameId, navigationId, tti);\n\n    const tbtValue =\n        Helpers.Timing.millisecondsToMicroseconds(Types.Timing.MilliSeconds(event.args.args.total_blocking_time_ms));\n    const tbtScore = Helpers.Timing.formatMicrosecondsTime(tbtValue, {\n      format: Types.Timing.TimeUnit.MILLISECONDS,\n      maximumFractionDigits: 2,\n    });\n    const tbt = {\n      event,\n      score: tbtScore,\n      metricName: MetricName.TBT,\n      classification: scoreClassificationForTotalBlockingTime(tbtValue),\n      navigation,\n    };\n    storeMetricScore(frameId, navigationId, tbt);\n    return;\n  }\n\n  if (Types.TraceEvents.isTraceEventLargestContentfulPaintCandidate(event)) {\n    const candidateIndex = event.args.data?.candidateIndex;\n    if (!candidateIndex) {\n      throw new Error('Largest Contenful Paint unexpectedly had no candidateIndex.');\n    }\n    const lcpTime = Types.Timing.MicroSeconds(event.ts - navigation.ts);\n    const lcpScore = Helpers.Timing.formatMicrosecondsTime(lcpTime, {\n      format: Types.Timing.TimeUnit.SECONDS,\n      maximumFractionDigits: 2,\n    });\n    const lcp = {\n      event,\n      score: lcpScore,\n      metricName: MetricName.LCP,\n      classification: scoreClassificationForLargestContentfulPaint(lcpTime),\n      navigation,\n    };\n    const metricsByNavigation = Platform.MapUtilities.getWithDefault(metricScoresByFrameId, frameId, () => new Map());\n    const metrics = Platform.MapUtilities.getWithDefault(metricsByNavigation, navigationId, () => new Map());\n    const lastLCPCandidate = metrics.get(MetricName.LCP);\n    if (lastLCPCandidate === undefined) {\n      selectedLCPCandidateEvents.add(lcp.event);\n      storeMetricScore(frameId, navigationId, lcp);\n      return;\n    }\n    const lastLCPCandidateEvent = lastLCPCandidate.event;\n\n    if (!Types.TraceEvents.isTraceEventLargestContentfulPaintCandidate(lastLCPCandidateEvent)) {\n      return;\n    }\n    const lastCandidateIndex = lastLCPCandidateEvent.args.data?.candidateIndex;\n    if (!lastCandidateIndex) {\n      // lastCandidateIndex cannot be undefined because don't store candidates with\n      // with an undefined candidateIndex value. This check is only to make TypeScript\n      // treat the field as not undefined below.\n      return;\n    }\n    if (lastCandidateIndex < candidateIndex) {\n      selectedLCPCandidateEvents.delete(lastLCPCandidateEvent);\n      selectedLCPCandidateEvents.add(lcp.event);\n      storeMetricScore(frameId, navigationId, lcp);\n    }\n    return;\n  }\n  if (Types.TraceEvents.isTraceEventLayoutShift(event)) {\n    return;\n  }\n  return Platform.assertNever(event, `Unexpected event type: ${event}`);\n}\n\nfunction storeMetricScore(frameId: string, navigationId: string, metricScore: MetricScore): void {\n  const metricsByNavigation = Platform.MapUtilities.getWithDefault(metricScoresByFrameId, frameId, () => new Map());\n  const metrics = Platform.MapUtilities.getWithDefault(metricsByNavigation, navigationId, () => new Map());\n  // If an entry with that metric name is present, delete it so that the new entry that\n  // will replace it is added at the end of the map. This way we guarantee the map entries\n  // are ordered in ASC manner by timestamp.\n  metrics.delete(metricScore.metricName);\n  metrics.set(metricScore.metricName, metricScore);\n}\n\nfunction getFrameIdForPageLoadEvent(event: Types.TraceEvents.PageLoadEvent): string {\n  if (Types.TraceEvents.isTraceEventFirstContentfulPaint(event) ||\n      Types.TraceEvents.isTraceEventInteractiveTime(event) ||\n      Types.TraceEvents.isTraceEventLargestContentfulPaintCandidate(event) ||\n      Types.TraceEvents.isTraceEventLayoutShift(event)) {\n    return event.args.frame;\n  }\n  if (Types.TraceEvents.isTraceEventMarkDOMContent(event)) {\n    const frameId = event.args.data?.frame;\n    if (!frameId) {\n      throw new Error('MarkDOMContent unexpectedly had no frame ID.');\n    }\n    return frameId;\n  }\n  Platform.assertNever(event, `Unexpected event type: ${event}`);\n}\n\nfunction getNavigationForPageLoadEvent(event: Types.TraceEvents.PageLoadEvent):\n    Types.TraceEvents.TraceEventNavigationStart|null {\n  if (Types.TraceEvents.isTraceEventFirstContentfulPaint(event) ||\n      Types.TraceEvents.isTraceEventLargestContentfulPaintCandidate(event)) {\n    const navigationId = event.args.data?.navigationId;\n    if (!navigationId) {\n      throw new Error('Trace event unexpectedly had no navigation ID.');\n    }\n    const {navigationsByNavigationId} = metaHandlerData();\n    const navigation = navigationsByNavigationId.get(navigationId);\n\n    if (!navigation) {\n      // This event's navigation has been filtered out by the meta handler as a noise event.\n      return null;\n    }\n    return navigation;\n  }\n\n  if (Types.TraceEvents.isTraceEventMarkDOMContent(event) || Types.TraceEvents.isTraceEventInteractiveTime(event) ||\n      Types.TraceEvents.isTraceEventLayoutShift(event)) {\n    const frameId = getFrameIdForPageLoadEvent(event);\n    const {navigationsByFrameId} = metaHandlerData();\n    return Helpers.Trace.getNavigationForTraceEvent(event, frameId, navigationsByFrameId);\n  }\n\n  return Platform.assertNever(event, `Unexpected event type: ${event}`);\n}\n\n/**\n * This methods calculates the Total Blocking Time for navigations for which\n * an InteractiveTime event wasn't recorded, that is, navigations without a\n * TBT reported by the backend. This could happen for example if the user\n * stops the recording before the page has settled. Although TBT is officially\n * the sum of the blocking portion of all long tasks between FCP and TTI, we\n * can still report the blocking time between FCP and the instant the recording\n * was stopped, in case TTI wasn't reached.\n */\nfunction estimateTotalBlockingTimes(): void {\n  const {processes} = rendererHandlerData();\n  const LONG_TASK_THRESHOLD = Helpers.Timing.millisecondsToMicroseconds(Types.Timing.MilliSeconds(50));\n  for (const [frameId, metricsByNavigation] of metricScoresByFrameId) {\n    for (const [navigationId, metrics] of metricsByNavigation) {\n      const navigationTBT = metrics.get(MetricName.TBT);\n      const navigationFCP = metrics.get(MetricName.FCP);\n      if (navigationTBT || !navigationFCP) {\n        // Either a TBT record was reported for this navigation so we don't\n        // need to estimate its value, or FCP wasn't reached so we can't\n        // estimate it.\n        continue;\n      }\n      if (!navigationFCP.event) {\n        continue;\n      }\n\n      // Get Main Thread information\n      const renderer = processes.get(navigationFCP.event.pid);\n      if (!renderer) {\n        // This can happen if the navigation was on a process that had no\n        // origin, or an origin we discard, such as about:blank. In this case\n        // we can discard the navigation as it's not relevant and we don't need\n        // to use it to calculate TBT.\n        continue;\n      }\n      const mainThread = [...renderer.threads.values()].find(thread => thread.name === 'CrRendererMain');\n      const mainThreadTree = mainThread?.tree;\n      if (!mainThread || !mainThreadTree) {\n        throw new Error('Main thread not found.');\n      }\n      const mainThreadEvents = mainThread.events;\n      const mainThreadNodes = mainThreadTree.nodes;\n      const fcpTs = navigationFCP.event.ts;\n      // Calulate TBT from Main Thread tasks.\n      let tbt = 0;\n      for (const rootId of mainThreadTree.roots) {\n        const node = mainThreadNodes.get(rootId);\n        if (node === undefined) {\n          throw new Error(`Node not found for id: ${rootId}`);\n        }\n        if (mainThreadEvents[node.eventIndex] === undefined) {\n          throw new Error(`Event not found for index: ${node.eventIndex}`);\n        }\n        const task = mainThreadEvents[node.eventIndex];\n        if (task.name !== KnownEventName.RunTask || Types.TraceEvents.isTraceEventInstant(task)) {\n          continue;\n        }\n\n        // Discard event if it ended before FCP.\n        if (task.ts + task.dur < fcpTs) {\n          continue;\n        }\n\n        // Following Lighthouse guidance, get the portion of the task occured after FCP\n        // before calculating its blocking portion (because tasks before FCP are\n        // unimportant, we consider only the blocking time after FCP).\n        const timeAfterFCP = task.ts < fcpTs ? fcpTs - task.ts : 0;\n        const clippedTaskDuration = task.dur - timeAfterFCP;\n        tbt += clippedTaskDuration > LONG_TASK_THRESHOLD ? clippedTaskDuration - LONG_TASK_THRESHOLD : 0;\n      }\n\n      const tbtValue = Types.Timing.MicroSeconds(tbt);\n      const tbtScore = Helpers.Timing.formatMicrosecondsTime(tbtValue, {\n        format: Types.Timing.TimeUnit.MILLISECONDS,\n        maximumFractionDigits: 2,\n      });\n      const tbtMetric = {\n        score: tbtScore,\n        estimated: true,\n        metricName: MetricName.TBT,\n        classification: scoreClassificationForTotalBlockingTime(tbtValue),\n        navigation: navigationFCP.navigation,\n      };\n      storeMetricScore(frameId, navigationId, tbtMetric);\n    }\n  }\n}\n\n/*\n * When we first load a new trace, rather than position the playhead at time 0,\n* we want to position it such that the thumbnail likely shows something rather\n* than a blank white page, and so that it's positioned somewhere that's useful\n* for the user.  This function takes the model data, and returns either the\n* timestamp of the first FCP event, or null if it couldn't find one.\n */\nexport function getFirstFCPTimestampFromModelData(model: HandlerData<Handlers>): Types.Timing.MicroSeconds|null {\n  const mainFrameID = model.Meta.mainFrameId;\n  const metricsForMainFrameByNavigationID = model.PageLoadMetrics.metricScoresByFrameId.get(mainFrameID);\n  if (!metricsForMainFrameByNavigationID) {\n    return null;\n  }\n\n  // Now find the first FCP event by timestamp. Events may not have the raw\n  // data including timestamp, and if so we skip that event.\n  let firstFCPEventInTimeline: Types.Timing.MicroSeconds|null = null;\n  for (const metrics of metricsForMainFrameByNavigationID.values()) {\n    const fcpMetric = metrics.get(MetricName.FCP);\n    const fcpTimestamp = fcpMetric?.event?.ts;\n    if (fcpTimestamp) {\n      if (!firstFCPEventInTimeline) {\n        firstFCPEventInTimeline = fcpTimestamp;\n      } else if (fcpTimestamp < firstFCPEventInTimeline) {\n        firstFCPEventInTimeline = fcpTimestamp;\n      }\n    }\n  }\n  return firstFCPEventInTimeline;\n}\n\n/**\n * Classifications sourced from\n * https://web.dev/fcp/\n */\n\nexport function scoreClassificationForFirstContentfulPaint(fcpScoreInMicroseconds: Types.Timing.MicroSeconds):\n    ScoreClassification {\n  const FCP_GOOD_TIMING = Helpers.Timing.secondsToMicroseconds(Types.Timing.Seconds(1.8));\n  const FCP_MEDIUM_TIMING = Helpers.Timing.secondsToMicroseconds(Types.Timing.Seconds(3.0));\n  let scoreClassification = ScoreClassification.BAD;\n  if (fcpScoreInMicroseconds <= FCP_MEDIUM_TIMING) {\n    scoreClassification = ScoreClassification.OK;\n  }\n  if (fcpScoreInMicroseconds <= FCP_GOOD_TIMING) {\n    scoreClassification = ScoreClassification.GOOD;\n  }\n  return scoreClassification;\n}\n\n/**\n * Classifications sourced from\n * https://web.dev/interactive/#how-lighthouse-determines-your-tti-score\n */\n\nexport function scoreClassificationForTimeToInteractive(ttiTimeInMicroseconds: Types.Timing.MicroSeconds):\n    ScoreClassification {\n  const TTI_GOOD_TIMING = Helpers.Timing.secondsToMicroseconds(Types.Timing.Seconds(3.8));\n  const TTI_MEDIUM_TIMING = Helpers.Timing.secondsToMicroseconds(Types.Timing.Seconds(7.3));\n  let scoreClassification = ScoreClassification.BAD;\n  if (ttiTimeInMicroseconds <= TTI_MEDIUM_TIMING) {\n    scoreClassification = ScoreClassification.OK;\n  }\n  if (ttiTimeInMicroseconds <= TTI_GOOD_TIMING) {\n    scoreClassification = ScoreClassification.GOOD;\n  }\n  return scoreClassification;\n}\n\n/**\n * Classifications sourced from\n * https://web.dev/lcp/#what-is-lcp\n */\n\nexport function scoreClassificationForLargestContentfulPaint(lcpTimeInMicroseconds: Types.Timing.MicroSeconds):\n    ScoreClassification {\n  const LCP_GOOD_TIMING = Helpers.Timing.secondsToMicroseconds(Types.Timing.Seconds(2.5));\n  const LCP_MEDIUM_TIMING = Helpers.Timing.secondsToMicroseconds(Types.Timing.Seconds(4));\n  let scoreClassification = ScoreClassification.BAD;\n  if (lcpTimeInMicroseconds <= LCP_MEDIUM_TIMING) {\n    scoreClassification = ScoreClassification.OK;\n  }\n  if (lcpTimeInMicroseconds <= LCP_GOOD_TIMING) {\n    scoreClassification = ScoreClassification.GOOD;\n  }\n  return scoreClassification;\n}\n\n/**\n * DCL does not have a classification.\n */\nexport function scoreClassificationForDOMContentLoaded(_dclTimeInMicroseconds: Types.Timing.MicroSeconds):\n    ScoreClassification {\n  return ScoreClassification.UNCLASSIFIED;\n}\n\n/**\n * Classifications sourced from\n * https://web.dev/lighthouse-total-blocking-#time/\n */\n\nexport function scoreClassificationForTotalBlockingTime(tbtTimeInMicroseconds: Types.Timing.MicroSeconds):\n    ScoreClassification {\n  const TBT_GOOD_TIMING = Helpers.Timing.millisecondsToMicroseconds(Types.Timing.MilliSeconds(200));\n  const TBT_MEDIUM_TIMING = Helpers.Timing.millisecondsToMicroseconds(Types.Timing.MilliSeconds(600));\n  let scoreClassification = ScoreClassification.BAD;\n  if (tbtTimeInMicroseconds <= TBT_MEDIUM_TIMING) {\n    scoreClassification = ScoreClassification.OK;\n  }\n  if (tbtTimeInMicroseconds <= TBT_GOOD_TIMING) {\n    scoreClassification = ScoreClassification.GOOD;\n  }\n  return scoreClassification;\n}\n\nexport async function finalize(): Promise<void> {\n  pageLoadEventsArray.sort((a, b) => a.ts - b.ts);\n\n  for (const pageLoadEvent of pageLoadEventsArray) {\n    const navigation = getNavigationForPageLoadEvent(pageLoadEvent);\n    if (navigation) {\n      // Event's navigation was not filtered out as noise.\n      storePageLoadMetricAgainstNavigationId(navigation, pageLoadEvent);\n    }\n  }\n  estimateTotalBlockingTimes();\n\n  // Now we have the final LCP candidate for each frame, let's try to fetch its\n  // DOMNode. This means that we can highlight it in the page, for example.\n  const lcpNodeIds = new Set<Protocol.DOM.BackendNodeId>();\n  for (const lcpEvent of selectedLCPCandidateEvents) {\n    if (lcpEvent.args.data) {\n      lcpNodeIds.add(lcpEvent.args.data.nodeId);\n    }\n  }\n}\n\nexport function data(): {\n  metricScoresByFrameId: Map<string, Map<string, Map<MetricName, MetricScore>>>,\n} {\n  return {\n    metricScoresByFrameId: new Map(metricScoresByFrameId),\n  };\n}\n\nexport function deps(): TraceEventHandlerName[] {\n  return ['Meta', 'Renderer'];\n}\n\nexport const enum ScoreClassification {\n  GOOD = 'good',\n  OK = 'ok',\n  BAD = 'bad',\n  // Some metrics (such as DOMContentLoaded) don't have a Good/OK/Bad classification, hence this additional entry.\n  UNCLASSIFIED = 'unclassified',\n}\n\nexport const enum MetricName {\n  FCP = 'FCP',\n  LCP = 'LCP',\n  DCL = 'DCL',\n  TTI = 'TTI',\n  TBT = 'TBT',\n  CLS = 'CLS',\n}\n\nexport interface MetricScore {\n  score: string;\n  metricName: MetricName;\n  classification: ScoreClassification;\n  event?: Types.TraceEvents.PageLoadEvent;\n  // The last navigation that occured before this metric score.\n  navigation?: Types.TraceEvents.TraceEventNavigationStart;\n  estimated?: boolean;\n}\n"],
  "mappings": "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",
  "names": []
}
