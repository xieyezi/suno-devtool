{
  "version": 3,
  "sources": ["../../../../../../../front_end/models/trace/handlers/LayoutShiftsHandler.ts"],
  "sourcesContent": ["// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Helpers from '../helpers/helpers.js';\n\nimport {type TraceEventHandlerName, HandlerState} from './types.js';\n\nimport {ScoreClassification} from './PageLoadMetricsHandler.js';\n\nimport {data as metaHandlerData} from './MetaHandler.js';\nimport {data as screenshotsHandlerData} from './ScreenshotsHandler.js';\nimport * as Platform from '../../../core/platform/platform.js';\n\nimport * as Types from '../types/types.js';\n\n// We start with a score of zero and step through all Layout Shift records from\n// all renderers. Each record not only tells us which renderer it is, but also\n// the unweighted and weighted scores. The unweighted score is the score we would\n// get if the renderer were the only one in the viewport. The weighted score, on\n// the other hand, accounts for how much of the viewport that particular render\n// takes up when the shift happened. An ad frame in the corner of the viewport\n// that shifts is considered less disruptive, therefore, than if it were taking\n// up the whole viewport.\n//\n// Next, we step through all the records from all renderers and add the weighted\n// score to a running total across all of the renderers. We create a new \"cluster\"\n// and reset the running total when:\n//\n// 1. We observe a top frame navigation, or\n// 2. When there's a gap between records of > 1s, or\n// 3. When there's more than 5 seconds of continuous layout shifting.\n//\n// Note that for it to be Cumulative Layout Shift in the sense described in the\n// documentation we would need to guarantee that we are tracking from navigation\n// to unload. However, we don't make any such guarantees here (since a developer\n// can record and stop when they please), so we support the cluster approach,\n// and we can give them a score, but it is effectively a \"session\" score, a\n// score for the given recording, and almost certainly not the\n// navigation-to-unload CLS score.\n\ninterface LayoutShifts {\n  clusters: LayoutShiftCluster[];\n  sessionMaxScore: number;\n  // The session window which contains the SessionMaxScore\n  clsWindowID: number;\n  // We use these to calculate root causes for a given LayoutShift\n  prePaintEvents: Types.TraceEvents.TraceEventPrePaint[];\n  layoutInvalidationEvents: Types.TraceEvents.TraceEventLayoutInvalidation[];\n  styleRecalcInvalidationEvents: Types.TraceEvents.TraceEventStyleRecalcInvalidation[];\n  scoreRecords: ScoreRecord[];\n}\n\n// This represents the maximum #time we will allow a cluster to go before we\n// reset it.\nexport const MAX_CLUSTER_DURATION = Helpers.Timing.millisecondsToMicroseconds(Types.Timing.MilliSeconds(5000));\n\n// This represents the maximum #time we will allow between layout shift events\n// before considering it to be the start of a new cluster.\nexport const MAX_SHIFT_TIME_DELTA = Helpers.Timing.millisecondsToMicroseconds(Types.Timing.MilliSeconds(1000));\n\n// Layout shifts are reported globally to the developer, irrespective of which\n// frame they originated in. However, each process does have its own individual\n// CLS score, so we need to segment by process. This means Layout Shifts from\n// sites with one process (no subframes, or subframes from the same origin)\n// will be reported together. In the case of multiple renderers (frames across\n// different origins), we offer the developer the ability to switch renderer in\n// the UI.\nconst layoutShiftEvents: Types.TraceEvents.TraceEventLayoutShift[] = [];\n\n// These events denote potential node resizings. We store them to link captured\n// layout shifts to the resizing of unsized elements.\nconst layoutInvalidationEvents: Types.TraceEvents.TraceEventLayoutInvalidation[] = [];\nconst styleRecalcInvalidationEvents: Types.TraceEvents.TraceEventStyleRecalcInvalidation[] = [];\n\n// Layout shifts happen during PrePaint as part of the rendering lifecycle.\n// We determine if a LayoutInvalidation event is a potential root cause of a layout\n// shift if the next PrePaint after the LayoutInvalidation is the parent\n// node of such shift.\nconst prePaintEvents: Types.TraceEvents.TraceEventPrePaint[] = [];\n\nlet sessionMaxScore = 0;\n\nlet clsWindowID = -1;\n\nconst clusters: LayoutShiftCluster[] = [];\n\n// Represents a point in time in which a  LS score change\n// was recorded.\ntype ScoreRecord = {\n  ts: number,\n  score: number,\n};\n\n// The complete timeline of LS score changes in a trace.\n// Includes drops to 0 when session windows end.\nconst scoreRecords: ScoreRecord[] = [];\n\nlet handlerState = HandlerState.UNINITIALIZED;\n\nexport function initialize(): void {\n  if (handlerState !== HandlerState.UNINITIALIZED) {\n    throw new Error('LayoutShifts Handler was not reset');\n  }\n  handlerState = HandlerState.INITIALIZED;\n}\n\nexport function reset(): void {\n  handlerState = HandlerState.UNINITIALIZED;\n  layoutShiftEvents.length = 0;\n  layoutInvalidationEvents.length = 0;\n  prePaintEvents.length = 0;\n  clusters.length = 0;\n  sessionMaxScore = 0;\n  scoreRecords.length = 0;\n  clsWindowID = -1;\n}\n\nexport function handleEvent(event: Types.TraceEvents.TraceEventData): void {\n  if (handlerState !== HandlerState.INITIALIZED) {\n    throw new Error('Handler is not initialized');\n  }\n\n  if (Types.TraceEvents.isTraceEventLayoutShift(event) && !event.args.data?.had_recent_input) {\n    layoutShiftEvents.push(event);\n    return;\n  }\n  if (Types.TraceEvents.isTraceEventLayoutInvalidation(event)) {\n    layoutInvalidationEvents.push(event);\n    return;\n  }\n  if (Types.TraceEvents.isTraceEventStyleRecalcInvalidation(event)) {\n    styleRecalcInvalidationEvents.push(event);\n  }\n  if (Types.TraceEvents.isTraceEventPrePaint(event)) {\n    prePaintEvents.push(event);\n    return;\n  }\n}\n\nfunction traceWindowFromTime(time: Types.Timing.MicroSeconds): Types.Timing.TraceWindow {\n  return {\n    min: time,\n    max: time,\n    range: Types.Timing.MicroSeconds(0),\n  };\n}\n\nfunction updateTraceWindowMax(traceWindow: Types.Timing.TraceWindow, newMax: Types.Timing.MicroSeconds): void {\n  traceWindow.max = newMax;\n  traceWindow.range = Types.Timing.MicroSeconds(traceWindow.max - traceWindow.min);\n}\n\nfunction findNextScreenshot(timestamp: Types.Timing.MicroSeconds): HTMLImageElement|undefined {\n  const screenshots = screenshotsHandlerData();\n  const screenshotIndex = findNextScreenshotEventIndex(screenshots, timestamp);\n  if (!screenshotIndex) {\n    return undefined;\n  }\n  const image = new Image();\n  image.src = `data:img/png;base64,${screenshots[screenshotIndex].args.snapshot}`;\n  return image;\n}\n\nexport function findNextScreenshotEventIndex(\n    screenshots: Types.TraceEvents.TraceEventSnapshot[], timestamp: Types.Timing.MicroSeconds): number|null {\n  return Platform.ArrayUtilities.nearestIndexFromBeginning(screenshots, frame => frame.ts > timestamp);\n}\n\nfunction buildScoreRecords(): void {\n  const {traceBounds} = metaHandlerData();\n  scoreRecords.push({ts: traceBounds.min, score: 0});\n\n  for (const cluster of clusters) {\n    let clusterScore = 0;\n    if (cluster.events[0].args.data) {\n      scoreRecords.push({ts: cluster.clusterWindow.min, score: cluster.events[0].args.data.weighted_score_delta});\n    }\n    for (let i = 0; i < cluster.events.length; i++) {\n      const event = cluster.events[i];\n      if (!event.args.data) {\n        continue;\n      }\n      clusterScore += event.args.data.weighted_score_delta;\n      scoreRecords.push({ts: event.ts, score: clusterScore});\n    }\n    scoreRecords.push({ts: cluster.clusterWindow.max, score: 0});\n  }\n}\n\nexport async function finalize(): Promise<void> {\n  // Ensure the events are sorted by #time ascending.\n  layoutShiftEvents.sort((a, b) => a.ts - b.ts);\n  prePaintEvents.sort((a, b) => a.ts - b.ts);\n  layoutInvalidationEvents.sort((a, b) => a.ts - b.ts);\n\n  // Each function transforms the data used by the next, as such the invoke order\n  // is important.\n  await buildLayoutShiftsClusters();\n  buildScoreRecords();\n  handlerState = HandlerState.FINALIZED;\n}\nasync function buildLayoutShiftsClusters(): Promise<void> {\n  const {navigationsByFrameId, mainFrameId, traceBounds} = metaHandlerData();\n  const navigations = navigationsByFrameId.get(mainFrameId) || [];\n  if (layoutShiftEvents.length === 0) {\n    return;\n  }\n  let firstShiftTime = layoutShiftEvents[0].ts;\n  let lastShiftTime = layoutShiftEvents[0].ts;\n  let lastShiftNavigation = null;\n  // Now step through each and create clusters.\n  // A cluster is equivalent to a session window (see https://web.dev/cls/#what-is-cls).\n  // To make the line chart clear, we explicitly demark the limits of each session window\n  // by starting the cumulative score of the window at the time of the first layout shift\n  // and ending it (dropping the line back to 0) when the window ends according to the\n  // thresholds (MAX_CLUSTER_DURATION, MAX_SHIFT_TIME_DELTA).\n  for (const event of layoutShiftEvents) {\n    // First detect if either the cluster duration or the #time between this and\n    // the last shift has been exceeded.\n    const clusterDurationExceeded = event.ts - firstShiftTime > MAX_CLUSTER_DURATION;\n    const maxTimeDeltaSinceLastShiftExceeded = event.ts - lastShiftTime > MAX_SHIFT_TIME_DELTA;\n\n    // Next take a look at navigations. If between this and the last shift we have navigated,\n    // note it.\n    const currentShiftNavigation = Platform.ArrayUtilities.nearestIndexFromEnd(navigations, nav => nav.ts < event.ts);\n    const hasNavigated = lastShiftNavigation !== currentShiftNavigation && currentShiftNavigation !== null;\n\n    // If any of the above criteria are met or if we don't have any cluster yet we should\n    // start a new one.\n    if (clusterDurationExceeded || maxTimeDeltaSinceLastShiftExceeded || hasNavigated || !clusters.length) {\n      // The cluster starts #time should be the timestamp of the first layout shift in it.\n      const clusterStartTime = event.ts;\n\n      // If the last session window ended because the max delta time between shifts\n      // was exceeded set the endtime to MAX_SHIFT_TIME_DELTA microseconds after the\n      // last shift in the session.\n      const endTimeByMaxSessionDuration = clusterDurationExceeded ? firstShiftTime + MAX_CLUSTER_DURATION : Infinity;\n\n      // If the last session window ended because the max session duration was\n      // surpassed, set the endtime so that the window length = MAX_CLUSTER_DURATION;\n      const endTimeByMaxShiftGap = maxTimeDeltaSinceLastShiftExceeded ? lastShiftTime + MAX_SHIFT_TIME_DELTA : Infinity;\n\n      // If there was a navigation during the last window, close it at the time\n      // of the navigation.\n      const endTimeByNavigation = hasNavigated ? navigations[currentShiftNavigation].ts : Infinity;\n\n      // End the previous cluster at the time of the first of the criteria above that was met.\n      const previousClusterEndTime = Math.min(endTimeByMaxSessionDuration, endTimeByMaxShiftGap, endTimeByNavigation);\n\n      // If there is an existing cluster update its closing time.\n      if (clusters.length > 0) {\n        const currentCluster = clusters[clusters.length - 1];\n        updateTraceWindowMax(currentCluster.clusterWindow, Types.Timing.MicroSeconds(previousClusterEndTime));\n      }\n\n      clusters.push({\n        events: [],\n        clusterWindow: traceWindowFromTime(clusterStartTime),\n        clusterCumulativeScore: 0,\n        scoreWindows: {\n          good: traceWindowFromTime(clusterStartTime),\n          needsImprovement: null,\n          bad: null,\n        },\n      });\n\n      firstShiftTime = clusterStartTime;\n    }\n\n    // Given the above we should have a cluster available, so pick the most\n    // recent one and append the shift, bump its score and window values accordingly.\n    const currentCluster = clusters[clusters.length - 1];\n    const timeFromNavigation = currentShiftNavigation !== null ?\n        Types.Timing.MicroSeconds(event.ts - navigations[currentShiftNavigation].ts) :\n        undefined;\n\n    currentCluster.clusterCumulativeScore += event.args.data ? event.args.data.weighted_score_delta : 0;\n    const shift: LayoutShift = {\n      ...event,\n      screenshot: findNextScreenshot(event.ts),\n      timeFromNavigation,\n      cumulativeWeightedScoreInWindow: currentCluster.clusterCumulativeScore,\n      // The score of the session window is temporarily set to 0 just\n      // to initialize it. Since we need to get the score of all shifts\n      // in the session window to determine its value, its definite\n      // value is set when stepping through the built clusters.\n      sessionWindowData: {cumulativeWindowScore: 0, id: clusters.length},\n    };\n    currentCluster.events.push(shift);\n    updateTraceWindowMax(currentCluster.clusterWindow, event.ts);\n\n    lastShiftTime = event.ts;\n    lastShiftNavigation = currentShiftNavigation;\n  }\n\n  // Now step through each cluster and set up the times at which the value\n  // goes from Good, to needs improvement, to Bad. Note that if there is a\n  // large jump we may go from Good to Bad without ever creating a Needs\n  // Improvement window at all.\n  for (const cluster of clusters) {\n    let weightedScore = 0;\n    let windowID = -1;\n    // If this is the last cluster update its window. The cluster duration is determined\n    // by the minimum between: time to next navigation, trace end time, time to maximum\n    // cluster duration and time to maximum gap between layout shifts.\n    if (cluster === clusters[clusters.length - 1]) {\n      const clusterEndByMaxDuration = MAX_CLUSTER_DURATION + cluster.clusterWindow.min;\n      const clusterEndByMaxGap = cluster.clusterWindow.max + MAX_SHIFT_TIME_DELTA;\n      const nextNavigationIndex =\n          Platform.ArrayUtilities.nearestIndexFromBeginning(navigations, nav => nav.ts > cluster.clusterWindow.max);\n      const nextNavigationTime = nextNavigationIndex ? navigations[nextNavigationIndex].ts : Infinity;\n      const clusterEnd = Math.min(clusterEndByMaxDuration, clusterEndByMaxGap, traceBounds.max, nextNavigationTime);\n      updateTraceWindowMax(cluster.clusterWindow, Types.Timing.MicroSeconds(clusterEnd));\n    }\n    for (const shift of cluster.events) {\n      weightedScore += shift.args.data ? shift.args.data.weighted_score_delta : 0;\n      windowID = shift.sessionWindowData.id;\n      // Update the the CLS score of this shift's session window now that\n      // we have it.\n      shift.sessionWindowData.cumulativeWindowScore = cluster.clusterCumulativeScore;\n      if (weightedScore < LayoutShiftsThreshold.NEEDS_IMPROVEMENT) {\n        // Expand the Good window.\n        updateTraceWindowMax(cluster.scoreWindows.good, shift.ts);\n      } else if (\n          weightedScore >= LayoutShiftsThreshold.NEEDS_IMPROVEMENT && weightedScore < LayoutShiftsThreshold.BAD) {\n        if (!cluster.scoreWindows.needsImprovement) {\n          // Close the Good window, and open the NI window.\n          updateTraceWindowMax(cluster.scoreWindows.good, Types.Timing.MicroSeconds(shift.ts - 1));\n          cluster.scoreWindows.needsImprovement = traceWindowFromTime(shift.ts);\n        }\n\n        // Expand the NI window.\n        updateTraceWindowMax(cluster.scoreWindows.needsImprovement, shift.ts);\n      } else if (weightedScore >= LayoutShiftsThreshold.BAD) {\n        if (!cluster.scoreWindows.bad) {\n          // We may jump from Good to Bad here, so update whichever window is open.\n          if (cluster.scoreWindows.needsImprovement) {\n            updateTraceWindowMax(cluster.scoreWindows.needsImprovement, Types.Timing.MicroSeconds(shift.ts - 1));\n          } else {\n            updateTraceWindowMax(cluster.scoreWindows.good, Types.Timing.MicroSeconds(shift.ts - 1));\n          }\n\n          cluster.scoreWindows.bad = traceWindowFromTime(shift.ts);\n        }\n\n        // Expand the Bad window.\n        updateTraceWindowMax(cluster.scoreWindows.bad, shift.ts);\n      }\n\n      // At this point the windows are set by the timestamps of the events, but the\n      // next cluster begins at the timestamp of its first event. As such we now\n      // need to expand the score window to the end of the cluster, and we do so\n      // by using the Bad widow if it's there, or the NI window, or finally the\n      // Good window.\n      if (cluster.scoreWindows.bad) {\n        updateTraceWindowMax(cluster.scoreWindows.bad, cluster.clusterWindow.max);\n      } else if (cluster.scoreWindows.needsImprovement) {\n        updateTraceWindowMax(cluster.scoreWindows.needsImprovement, cluster.clusterWindow.max);\n      } else {\n        updateTraceWindowMax(cluster.scoreWindows.good, cluster.clusterWindow.max);\n      }\n    }\n    if (weightedScore > sessionMaxScore) {\n      clsWindowID = windowID;\n      sessionMaxScore = weightedScore;\n    }\n  }\n}\n\nexport function data(): LayoutShifts {\n  if (handlerState !== HandlerState.FINALIZED) {\n    throw new Error('Layout Shifts Handler is not finalized');\n  }\n\n  return {\n    clusters: [...clusters],\n    sessionMaxScore: sessionMaxScore,\n    clsWindowID,\n    prePaintEvents: [...prePaintEvents],\n    layoutInvalidationEvents: [...layoutInvalidationEvents],\n    styleRecalcInvalidationEvents: [],\n    scoreRecords: [...scoreRecords],\n  };\n}\n\nexport function deps(): TraceEventHandlerName[] {\n  return ['Screenshots', 'Meta'];\n}\n\nexport function stateForLayoutShiftScore(score: number): ScoreClassification {\n  let state = ScoreClassification.GOOD;\n  if (score >= LayoutShiftsThreshold.NEEDS_IMPROVEMENT) {\n    state = ScoreClassification.OK;\n  }\n\n  if (score >= LayoutShiftsThreshold.BAD) {\n    state = ScoreClassification.BAD;\n  }\n\n  return state;\n}\n\ninterface LayoutShiftSessionWindowData {\n  // The sum of the weighted score of all the shifts\n  // that belong to a session window.\n  cumulativeWindowScore: number;\n  // A consecutive generated in the frontend to\n  // to identify a session window.\n  id: number;\n}\ninterface LayoutShiftData {\n  screenshot?: HTMLImageElement;\n  timeFromNavigation?: Types.Timing.MicroSeconds;\n  // The sum of the weighted scores of the shifts that\n  // belong to a session window up until this shift\n  // (inclusive).\n  cumulativeWeightedScoreInWindow: number;\n  sessionWindowData: LayoutShiftSessionWindowData;\n}\nexport type LayoutShift = Types.TraceEvents.TraceEventLayoutShift&LayoutShiftData;\n\nexport interface LayoutShiftCluster {\n  clusterWindow: Types.Timing.TraceWindow;\n  clusterCumulativeScore: number;\n  events: LayoutShift[];\n  // For convenience we split apart the cluster into good, NI, and bad windows.\n  // Since a cluster may remain in the good window, we mark NI and bad as being\n  // possibly null.\n  scoreWindows: {\n    good: Types.Timing.TraceWindow,\n    needsImprovement: Types.Timing.TraceWindow|null,\n    bad: Types.Timing.TraceWindow|null,\n  };\n}\n\n// Based on https://web.dev/cls/\nexport const enum LayoutShiftsThreshold {\n  GOOD = 0,\n  NEEDS_IMPROVEMENT = 0.1,\n  BAD = 0.25,\n}\n"],
  "mappings": "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",
  "names": []
}
