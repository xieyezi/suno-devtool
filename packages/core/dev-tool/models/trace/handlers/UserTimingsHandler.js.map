{
  "version": 3,
  "sources": ["../../../../../../../front_end/models/trace/handlers/UserTimingsHandler.ts"],
  "sourcesContent": ["// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as Types from '../types/types.js';\n\nimport {HandlerState} from './types.js';\n\n/**\n * IMPORTANT!\n * See UserTimings.md in this directory for some handy documentation on\n * UserTimings and the trace events we parse currently.\n **/\nconst syntheticEvents: Types.TraceEvents.TraceEventSyntheticUserTiming[] = [];\n\nconst timingEvents: (Types.TraceEvents.TraceEventUserTimingBegin|Types.TraceEvents.TraceEventUserTimingEnd)[] = [];\n\ninterface UserTimingsData {\n  timings: readonly Types.TraceEvents.TraceEventSyntheticUserTiming[];\n}\nlet handlerState = HandlerState.UNINITIALIZED;\n\nexport function reset(): void {\n  syntheticEvents.length = 0;\n  timingEvents.length = 0;\n  handlerState = HandlerState.INITIALIZED;\n}\n\nexport function handleEvent(event: Types.TraceEvents.TraceEventData): void {\n  if (handlerState !== HandlerState.INITIALIZED) {\n    throw new Error('UserTimings handler is not initialized');\n  }\n\n  if (Types.TraceEvents.isTraceEventUserTimingsBeginOrEnd(event)) {\n    timingEvents.push(event);\n  }\n}\n\nexport async function finalize(): Promise<void> {\n  if (handlerState !== HandlerState.INITIALIZED) {\n    throw new Error('UserTimings handler is not initialized');\n  }\n\n  const matchedEvents: Map<string, {\n    begin: Types.TraceEvents.TraceEventUserTimingBegin | null,\n    end: Types.TraceEvents.TraceEventUserTimingEnd | null,\n  }> = new Map();\n  for (const event of timingEvents) {\n    const otherEventsWithID = Platform.MapUtilities.getWithDefault(matchedEvents, event.id, () => {\n      return {begin: null, end: null};\n    });\n    const isStartEvent = event.ph === Types.TraceEvents.TraceEventPhase.ASYNC_NESTABLE_START;\n    const isEndEvent = event.ph === Types.TraceEvents.TraceEventPhase.ASYNC_NESTABLE_END;\n\n    if (isStartEvent) {\n      otherEventsWithID.begin = event;\n    } else if (isEndEvent) {\n      otherEventsWithID.end = event;\n    }\n  }\n\n  for (const [id, eventsPair] of matchedEvents.entries()) {\n    if (!eventsPair.begin || !eventsPair.end) {\n      // This should never happen, the backend only creates the events once it\n      // has them both, so we should never get into this state.\n      // If we do, something is very wrong, so let's just drop that problematic event.\n      continue;\n    }\n\n    const event: Types.TraceEvents.TraceEventSyntheticUserTiming = {\n      cat: eventsPair.end.cat,\n      ph: eventsPair.end.ph,\n      pid: eventsPair.end.pid,\n      tid: eventsPair.end.tid,\n      id,\n      // Both events have the same name, so it doesn't matter which we pick to\n      // use as the description\n      name: eventsPair.begin.name,\n      dur: Types.Timing.MicroSeconds(eventsPair.end.ts - eventsPair.begin.ts),\n      ts: eventsPair.begin.ts,\n      args: {\n        data: {\n          beginEvent: eventsPair.begin,\n          endEvent: eventsPair.end,\n        },\n      },\n    };\n    syntheticEvents.push(event);\n  }\n  syntheticEvents.sort((event1, event2) => {\n    if (event1.ts > event2.ts) {\n      return 1;\n    }\n    if (event2.ts > event1.ts) {\n      return -1;\n    }\n    return 0;\n  });\n  handlerState = HandlerState.FINALIZED;\n}\n\nexport function data(): UserTimingsData {\n  if (handlerState !== HandlerState.FINALIZED) {\n    throw new Error('UserTimings handler is not finalized');\n  }\n\n  return {\n    timings: [...syntheticEvents],\n  };\n}\n"],
  "mappings": "AAIA;AACA;AAEA;AAOA,MAAM,kBAAqE;AAE3E,MAAM,eAA0G;AAKhH,IAAI,eAAe,aAAa;AAEzB,wBAAuB;AAC5B,kBAAgB,SAAS;AACzB,eAAa,SAAS;AACtB,iBAAe,aAAa;AAAA;AAGvB,4BAAqB,OAA+C;AACzE,MAAI,iBAAiB,aAAa,aAAa;AAC7C,UAAM,IAAI,MAAM;AAAA;AAGlB,MAAI,MAAM,YAAY,kCAAkC,QAAQ;AAC9D,iBAAa,KAAK;AAAA;AAAA;AAItB,iCAAgD;AAC9C,MAAI,iBAAiB,aAAa,aAAa;AAC7C,UAAM,IAAI,MAAM;AAAA;AAGlB,QAAM,gBAGD,oBAAI;AACT,aAAW,SAAS,cAAc;AAChC,UAAM,oBAAoB,SAAS,aAAa,eAAe,eAAe,MAAM,IAAI,MAAM;AAC5F,aAAO,EAAC,OAAO,MAAM,KAAK;AAAA;AAE5B,UAAM,eAAe,MAAM,OAAO,MAAM,YAAY,gBAAgB;AACpE,UAAM,aAAa,MAAM,OAAO,MAAM,YAAY,gBAAgB;AAElE,QAAI,cAAc;AAChB,wBAAkB,QAAQ;AAAA,eACjB,YAAY;AACrB,wBAAkB,MAAM;AAAA;AAAA;AAI5B,aAAW,CAAC,IAAI,eAAe,cAAc,WAAW;AACtD,QAAI,CAAC,WAAW,SAAS,CAAC,WAAW,KAAK;AAIxC;AAAA;AAGF,UAAM,QAAyD;AAAA,MAC7D,KAAK,WAAW,IAAI;AAAA,MACpB,IAAI,WAAW,IAAI;AAAA,MACnB,KAAK,WAAW,IAAI;AAAA,MACpB,KAAK,WAAW,IAAI;AAAA,MACpB;AAAA,MAGA,MAAM,WAAW,MAAM;AAAA,MACvB,KAAK,MAAM,OAAO,aAAa,WAAW,IAAI,KAAK,WAAW,MAAM;AAAA,MACpE,IAAI,WAAW,MAAM;AAAA,MACrB,MAAM;AAAA,QACJ,MAAM;AAAA,UACJ,YAAY,WAAW;AAAA,UACvB,UAAU,WAAW;AAAA;AAAA;AAAA;AAI3B,oBAAgB,KAAK;AAAA;AAEvB,kBAAgB,KAAK,CAAC,QAAQ,WAAW;AACvC,QAAI,OAAO,KAAK,OAAO,IAAI;AACzB,aAAO;AAAA;AAET,QAAI,OAAO,KAAK,OAAO,IAAI;AACzB,aAAO;AAAA;AAET,WAAO;AAAA;AAET,iBAAe,aAAa;AAAA;AAGvB,uBAAiC;AACtC,MAAI,iBAAiB,aAAa,WAAW;AAC3C,UAAM,IAAI,MAAM;AAAA;AAGlB,SAAO;AAAA,IACL,SAAS,CAAC,GAAG;AAAA;AAAA;",
  "names": []
}
