{
  "version": 3,
  "sources": ["../../../../../../../front_end/models/trace/handlers/MetaHandler.ts"],
  "sourcesContent": ["// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport * as Types from '../types/types.js';\n\nimport {HandlerState} from './types.js';\n\n// We track the renderer processes we see in each frame on the way through the trace.\nconst rendererProcessesByFrameId = new Map<\n    string,\n    Map<Types.TraceEvents.ProcessID, {window: Types.Timing.TraceWindow, frame: Types.TraceEvents.TraceFrame}>>();\n\n// We will often want to key data by Frame IDs, and commonly we'll care most\n// about the main frame's ID, so we store and expose that.\nlet mainFrameId: string = '';\nlet mainFrameURL: string = '';\n\n// We will often want to key data by the browser process, GPU process and top\n// level renderer IDs, so keep a track on those.\nlet browserProcessId: Types.TraceEvents.ProcessID = Types.TraceEvents.ProcessID(-1);\nlet browserThreadId: Types.TraceEvents.ThreadID = Types.TraceEvents.ThreadID(-1);\nlet gpuProcessId: Types.TraceEvents.ProcessID = Types.TraceEvents.ProcessID(-1);\nlet gpuThreadId: Types.TraceEvents.ThreadID = Types.TraceEvents.ThreadID(-1);\nlet viewportRect: DOMRect|null = null;\n\nconst topLevelRendererIds = new Set<Types.TraceEvents.ProcessID>();\nconst traceBounds: Types.Timing.TraceWindow = {\n  min: Types.Timing.MicroSeconds(Number.POSITIVE_INFINITY),\n  max: Types.Timing.MicroSeconds(Number.NEGATIVE_INFINITY),\n  range: Types.Timing.MicroSeconds(Number.POSITIVE_INFINITY),\n};\n\n/**\n * These represent the user navigating. Values such as First Contentful Paint,\n * etc, are relative to the navigation.\n *\n *  We store navigation events both by the frame and navigation ID. This means\n * when we need to look them up, we can use whichever ID we have.\n *\n * Note that these Maps will have the same values in them; these are just keyed\n * differently to make look-ups easier.\n */\nconst navigationsByFrameId = new Map<string, Types.TraceEvents.TraceEventNavigationStart[]>();\nconst navigationsByNavigationId = new Map<string, Types.TraceEvents.TraceEventNavigationStart>();\n\n// Represents all the threads in the trace, organized by process. This is mostly for internal\n// bookkeeping so that during the finalize pass we can obtain the main and browser thread IDs.\nconst threadsInProcess =\n    new Map<Types.TraceEvents.ProcessID, Map<Types.TraceEvents.ThreadID, Types.TraceEvents.TraceEventThreadName>>();\n\nlet traceStartedTime = Types.Timing.MicroSeconds(-1);\nconst eventPhasesOfInterestForTraceBounds = new Set([\n  Types.TraceEvents.TraceEventPhase.BEGIN,\n  Types.TraceEvents.TraceEventPhase.END,\n  Types.TraceEvents.TraceEventPhase.COMPLETE,\n  Types.TraceEvents.TraceEventPhase.INSTANT,\n]);\n\nlet handlerState = HandlerState.UNINITIALIZED;\nexport function reset(): void {\n  navigationsByFrameId.clear();\n  navigationsByNavigationId.clear();\n\n  browserProcessId = Types.TraceEvents.ProcessID(-1);\n  browserThreadId = Types.TraceEvents.ThreadID(-1);\n  gpuProcessId = Types.TraceEvents.ProcessID(-1);\n  gpuThreadId = Types.TraceEvents.ThreadID(-1);\n  viewportRect = null;\n  topLevelRendererIds.clear();\n  threadsInProcess.clear();\n  rendererProcessesByFrameId.clear();\n\n  traceBounds.min = Types.Timing.MicroSeconds(Number.POSITIVE_INFINITY);\n  traceBounds.max = Types.Timing.MicroSeconds(Number.NEGATIVE_INFINITY);\n  traceBounds.range = Types.Timing.MicroSeconds(Number.POSITIVE_INFINITY);\n  traceStartedTime = Types.Timing.MicroSeconds(-1);\n\n  handlerState = HandlerState.UNINITIALIZED;\n}\n\nexport function initialize(): void {\n  if (handlerState !== HandlerState.UNINITIALIZED) {\n    throw new Error('Meta Handler was not reset');\n  }\n\n  handlerState = HandlerState.INITIALIZED;\n}\n\nfunction updateRendererProcessByFrame(\n    event: Types.TraceEvents.TraceEventData, frame: Types.TraceEvents.TraceFrame): void {\n  const rendererProcessInFrame = Platform.MapUtilities.getWithDefault(\n      rendererProcessesByFrameId, frame.frame,\n      () => new Map<\n          Types.TraceEvents.ProcessID, {frame: Types.TraceEvents.TraceFrame, window: Types.Timing.TraceWindow}>());\n  const rendererProcessInfo = Platform.MapUtilities.getWithDefault(rendererProcessInFrame, frame.processId, () => {\n    return {\n      frame,\n      window: {\n        min: Types.Timing.MicroSeconds(0),\n        max: Types.Timing.MicroSeconds(0),\n        range: Types.Timing.MicroSeconds(0),\n      },\n    };\n  });\n\n  // If this window was already created, do nothing.\n  if (rendererProcessInfo.window.min !== Types.Timing.MicroSeconds(0)) {\n    return;\n  }\n\n  // For now we store the time of the event as the min. In the finalize we step\n  // through each of these windows and update their max and range values.\n  rendererProcessInfo.window.min = event.ts;\n}\n\nexport function handleEvent(event: Types.TraceEvents.TraceEventData): void {\n  if (handlerState !== HandlerState.INITIALIZED) {\n    throw new Error('Meta Handler is not initialized');\n  }\n\n  // If there is a timestamp (which meta events do not have), and the event does\n  // not end with ::UMA then it, and the event is in the set of valid phases,\n  // then it should be included for the purposes of calculating the trace bounds.\n  // The UMA events in particular seem to be reported on page unloading, which\n  // often extends the bounds of the trace unhelpfully.\n  if (event.ts !== 0 && !event.name.endsWith('::UMA') && eventPhasesOfInterestForTraceBounds.has(event.ph)) {\n    traceBounds.min = Types.Timing.MicroSeconds(Math.min(event.ts, traceBounds.min));\n    const eventDuration = event.dur || Types.Timing.MicroSeconds(0);\n    traceBounds.max = Types.Timing.MicroSeconds(Math.max(event.ts + eventDuration, traceBounds.max));\n  }\n\n  if (Types.TraceEvents.isProcessName(event) &&\n      (event.args.name === 'Browser' || event.args.name === 'HeadlessBrowser')) {\n    browserProcessId = event.pid;\n    return;\n  }\n\n  if (Types.TraceEvents.isProcessName(event) && (event.args.name === 'Gpu' || event.args.name === 'GPU Process')) {\n    gpuProcessId = event.pid;\n    return;\n  }\n\n  if (Types.TraceEvents.isThreadName(event) && event.args.name === 'CrGpuMain') {\n    gpuThreadId = event.tid;\n    return;\n  }\n\n  if (Types.TraceEvents.isThreadName(event) && event.args.name === 'CrBrowserMain') {\n    browserThreadId = event.tid;\n  }\n\n  if (Types.TraceEvents.isTraceEventMainFrameViewport(event) && viewportRect === null) {\n    const rectAsArray = event.args.data.viewport_rect;\n    const viewportX = rectAsArray[0];\n    const viewportY = rectAsArray[1];\n    const viewportWidth = rectAsArray[2];\n    const viewportHeight = rectAsArray[5];\n    viewportRect = new DOMRect(viewportX, viewportY, viewportWidth, viewportHeight);\n  }\n\n  // The TracingStartedInBrowser event includes the data on which frames are\n  // in scope at the start of the trace. We use this to identify the frame with\n  // no parent, i.e. the top level frame.\n  if (Types.TraceEvents.isTraceEventTracingStartedInBrowser(event)) {\n    traceStartedTime = event.ts;\n\n    if (!event.args.data) {\n      throw new Error('No frames found in trace data');\n    }\n\n    for (const frame of event.args.data.frames) {\n      updateRendererProcessByFrame(event, frame);\n\n      if (frame.parent) {\n        continue;\n      }\n\n      mainFrameId = frame.frame;\n      mainFrameURL = frame.url;\n      topLevelRendererIds.add(frame.processId);\n    }\n    return;\n  }\n\n  // FrameCommittedInBrowser events tell us information about each frame\n  // and we use these to track how long each individual renderer is active\n  // for. We track all renderers here (top level and those in frames), but\n  // for convenience we also populate a set of top level renderer IDs.\n  if (Types.TraceEvents.isTraceEventFrameCommittedInBrowser(event)) {\n    const frame = event.args.data;\n    if (!frame) {\n      return;\n    }\n\n    updateRendererProcessByFrame(event, frame);\n\n    if (frame.parent) {\n      return;\n    }\n\n    topLevelRendererIds.add(frame.processId);\n    return;\n  }\n\n  if (Types.TraceEvents.isTraceEventCommitLoad(event)) {\n    const frameData = event.args.data;\n    if (!frameData) {\n      return;\n    }\n\n    const {frame, name, url} = frameData;\n    updateRendererProcessByFrame(event, {processId: event.pid, frame, name, url});\n    return;\n  }\n\n  // Track all threads based on the process & thread IDs.\n  if (Types.TraceEvents.isThreadName(event)) {\n    const threads = Platform.MapUtilities.getWithDefault(threadsInProcess, event.pid, () => new Map());\n    threads.set(event.tid, event);\n    return;\n  }\n\n  // Track all navigation events. Note that there can be navigation start events\n  // but where the documentLoaderURL is empty. As far as the trace rendering is\n  // concerned, these events are noise so we filter them out here.\n  if (Types.TraceEvents.isTraceEventNavigationStartWithURL(event) && event.args.data) {\n    const navigationId = event.args.data.navigationId;\n    if (navigationsByNavigationId.has(navigationId)) {\n      throw new Error('Found multiple navigation start events with the same navigation ID.');\n    }\n    navigationsByNavigationId.set(navigationId, event);\n\n    const frameId = event.args.frame;\n    const existingFrameNavigations = navigationsByFrameId.get(frameId) || [];\n    existingFrameNavigations.push(event);\n    navigationsByFrameId.set(frameId, existingFrameNavigations);\n    return;\n  }\n}\n\nexport async function finalize(): Promise<void> {\n  if (handlerState !== HandlerState.INITIALIZED) {\n    throw new Error('Handler is not initialized');\n  }\n\n  // If we haven't seen a TracingStartedInBrowser event then we don't\n  // support this trace file. As such, we throw an error here.\n  if (traceStartedTime === -1) {\n    throw new Error('Error parsing trace data: no TracingStartedInBrowser event found.');\n  }\n\n  traceBounds.min = traceStartedTime;\n  traceBounds.range = Types.Timing.MicroSeconds(traceBounds.max - traceBounds.min);\n\n  if (topLevelRendererIds.size === 0) {\n    throw new Error('Unable to find renderer processes');\n  }\n\n  if (browserProcessId === Types.TraceEvents.ProcessID(-1)) {\n    throw new Error('Unable to find browser process');\n  }\n\n  if (browserThreadId === Types.TraceEvents.ThreadID(-1)) {\n    throw new Error('Unable to find browser thread');\n  }\n\n  if (gpuProcessId === Types.TraceEvents.ProcessID(-1)) {\n    throw new Error('Unable to find GPU process');\n  }\n\n  // We purposefully don't check for a missing GPU Thread ID; it's possible\n  // that a trace ran and did not use a GPU Thread.\n\n  if (!mainFrameId) {\n    throw new Error('Unable to find main frame ID');\n  }\n\n  // If we go from foo.com to example.com we will get a new renderer, and\n  // therefore the \"top level renderer\" will have a different PID as it has\n  // changed. Here we step through each renderer process and updated its window\n  // bounds, such that we end up with the time ranges in the trace for when\n  // each particular renderer started and stopped being the main renderer\n  // process.\n  for (const [, processWindows] of rendererProcessesByFrameId) {\n    const processWindowValues = [...processWindows.values()];\n    for (let i = 0; i < processWindowValues.length; i++) {\n      const currentWindow = processWindowValues[i];\n      const nextWindow = processWindowValues[i + 1];\n\n      // For the last window we set its max to be positive infinity.\n      // TODO: Move the trace bounds handler into meta so we can clamp first and last windows.\n      if (!nextWindow) {\n        currentWindow.window.max = Types.Timing.MicroSeconds(traceBounds.max);\n        currentWindow.window.range = Types.Timing.MicroSeconds(traceBounds.max - currentWindow.window.min);\n      } else {\n        currentWindow.window.max = Types.Timing.MicroSeconds(nextWindow.window.min - 1);\n        currentWindow.window.range = Types.Timing.MicroSeconds(currentWindow.window.max - currentWindow.window.min);\n      }\n    }\n  }\n\n  // Frame ids which we didn't register using either the TracingStartedInBrowser or\n  // the FrameCommittedInBrowser events are considered noise, so we filter them out, as well\n  // as the navigations that belong to such frames.\n  for (const [frameId, navigations] of navigationsByFrameId) {\n    // The frames in the rendererProcessesByFrameId map come only from the\n    // TracingStartedInBrowser and FrameCommittedInBrowser events, so we can use it as point\n    // of comparison to determine if a frameId should be discarded.\n    if (rendererProcessesByFrameId.has(frameId)) {\n      continue;\n    }\n    navigationsByFrameId.delete(frameId);\n    for (const navigation of navigations) {\n      if (!navigation.args.data) {\n        continue;\n      }\n      navigationsByNavigationId.delete(navigation.args.data.navigationId);\n    }\n  }\n\n  handlerState = HandlerState.FINALIZED;\n}\n\ntype MetaHandlerData = {\n  traceBounds: Types.Timing.TraceWindow,\n  browserProcessId: Types.TraceEvents.ProcessID,\n  browserThreadId: Types.TraceEvents.ThreadID,\n  gpuProcessId: Types.TraceEvents.ProcessID,\n  gpuThreadId?: Types.TraceEvents.ThreadID,\n  viewportRect?: DOMRect,\n              navigationsByFrameId: Map<string, Types.TraceEvents.TraceEventNavigationStart[]>,\n              navigationsByNavigationId: Map<string, Types.TraceEvents.TraceEventNavigationStart>,\n              threadsInProcess:\n                  Map<Types.TraceEvents.ProcessID,\n                      Map<Types.TraceEvents.ThreadID, Types.TraceEvents.TraceEventThreadName>>,\n              mainFrameId: string,\n              mainFrameURL: string,\n              rendererProcessesByFrame:\n                  Map<string,\n                      Map<Types.TraceEvents.ProcessID,\n                          {frame: Types.TraceEvents.TraceFrame, window: Types.Timing.TraceWindow}>>,\n              topLevelRendererIds: Set<Types.TraceEvents.ProcessID>,\n};\n\nexport function data(): MetaHandlerData {\n  if (handlerState !== HandlerState.FINALIZED) {\n    throw new Error('Meta Handler is not finalized');\n  }\n\n  return {\n    traceBounds: {...traceBounds},\n    browserProcessId,\n    browserThreadId,\n    gpuProcessId,\n    gpuThreadId: gpuThreadId === Types.TraceEvents.ThreadID(-1) ? undefined : gpuThreadId,\n    viewportRect: viewportRect || undefined,\n    mainFrameId,\n    mainFrameURL,\n    navigationsByFrameId: new Map(navigationsByFrameId),\n    navigationsByNavigationId: new Map(navigationsByNavigationId),\n    threadsInProcess: new Map(threadsInProcess),\n    rendererProcessesByFrame: new Map(rendererProcessesByFrameId),\n    topLevelRendererIds: new Set(topLevelRendererIds),\n  };\n}\n"],
  "mappings": "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",
  "names": []
}
