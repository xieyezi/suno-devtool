{
  "version": 3,
  "sources": ["../../../../../../../front_end/models/trace/handlers/NetworkRequestsHandler.ts"],
  "sourcesContent": ["// Copyright 2022 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../../../core/platform/platform.js';\nimport {type TraceEventHandlerName, HandlerState} from './types.js';\n\nimport {data as metaHandlerData} from './MetaHandler.js';\n\nimport * as Types from '../types/types.js';\n\nconst MILLISECONDS_TO_MICROSECONDS = 1000;\nconst SECONDS_TO_MICROSECONDS = 1000000;\n\n// Network requests from traces are actually formed of 5 trace records.\n// This handler tracks all trace records based on the request ID, and\n// then creates a new synthetic trace event for those network requests.\n//\n// This interface, then, defines the shape of the object we intend to\n// keep for each request in the trace. In the finalize we will convert\n// these 5 types of trace records to a synthetic complete event that\n// represents a composite of these trace records.\ninterface TraceEventsForNetworkRequest {\n  willSendRequests?: Types.TraceEvents.TraceEventResourceWillSendRequest[];\n  sendRequests?: Types.TraceEvents.TraceEventResourceSendRequest[];\n  receiveResponse?: Types.TraceEvents.TraceEventResourceReceiveResponse;\n  resourceFinish?: Types.TraceEvents.TraceEventResourceFinish;\n  receivedData?: Types.TraceEvents.TraceEventResourceReceivedData[];\n}\n\ninterface NetworkRequestData {\n  byOrigin: Map<string, {\n    renderBlocking: Types.TraceEvents.TraceEventSyntheticNetworkRequest[],\n    nonRenderBlocking: Types.TraceEvents.TraceEventSyntheticNetworkRequest[],\n    all: Types.TraceEvents.TraceEventSyntheticNetworkRequest[],\n  }>;\n  byTime: Types.TraceEvents.TraceEventSyntheticNetworkRequest[];\n}\n\nconst requestMap = new Map<string, TraceEventsForNetworkRequest>();\nconst requestsByOrigin = new Map<string, {\n  renderBlocking: Types.TraceEvents.TraceEventSyntheticNetworkRequest[],\n  nonRenderBlocking: Types.TraceEvents.TraceEventSyntheticNetworkRequest[],\n  all: Types.TraceEvents.TraceEventSyntheticNetworkRequest[],\n}>();\nconst requestsByTime: Types.TraceEvents.TraceEventSyntheticNetworkRequest[] = [];\n\nfunction storeTraceEventWithRequestId<K extends keyof TraceEventsForNetworkRequest>(\n    requestId: string, key: K, value: TraceEventsForNetworkRequest[K]): void {\n  if (!requestMap.has(requestId)) {\n    requestMap.set(requestId, {});\n  }\n\n  const traceEvents = requestMap.get(requestId);\n  if (!traceEvents) {\n    throw new Error(`Unable to locate trace events for request ID ${requestId}`);\n  }\n\n  if (Array.isArray(traceEvents[key])) {\n    const target = traceEvents[key] as Types.TraceEvents.TraceEventData[];\n    const values = value as Types.TraceEvents.TraceEventData[];\n    target.push(...values);\n  } else {\n    traceEvents[key] = value;\n  }\n}\n\nfunction firstPositiveValueInList(entries: number[]): number {\n  for (const entry of entries) {\n    if (entry > 0) {\n      return entry;\n    }\n  }\n\n  // In the event we don't find a positive value, we return 0 so as to\n  // be a mathematical noop. It's typically not correct to return \u2013 say \u2013\n  // a -1 here because it would affect the calculation of stats below.\n  return 0;\n}\n\nlet handlerState = HandlerState.UNINITIALIZED;\n\nexport function reset(): void {\n  requestsByOrigin.clear();\n  requestMap.clear();\n  requestsByTime.length = 0;\n\n  handlerState = HandlerState.INITIALIZED;\n}\n\nexport function handleEvent(event: Types.TraceEvents.TraceEventData): void {\n  if (handlerState !== HandlerState.INITIALIZED) {\n    throw new Error('Network Request handler is not initialized');\n  }\n\n  if (Types.TraceEvents.isTraceEventResourceWillSendRequest(event)) {\n    storeTraceEventWithRequestId(event.args.data.requestId, 'willSendRequests', [event]);\n    return;\n  }\n\n  if (Types.TraceEvents.isTraceEventResourceSendRequest(event)) {\n    storeTraceEventWithRequestId(event.args.data.requestId, 'sendRequests', [event]);\n    return;\n  }\n\n  if (Types.TraceEvents.isTraceEventResourceReceiveResponse(event)) {\n    storeTraceEventWithRequestId(event.args.data.requestId, 'receiveResponse', event);\n    return;\n  }\n\n  if (Types.TraceEvents.isTraceEventResourceReceivedData(event)) {\n    storeTraceEventWithRequestId(event.args.data.requestId, 'receivedData', [event]);\n    return;\n  }\n\n  if (Types.TraceEvents.isTraceEventResourceFinish(event)) {\n    storeTraceEventWithRequestId(event.args.data.requestId, 'resourceFinish', event);\n    return;\n  }\n}\n\nexport async function finalize(): Promise<void> {\n  if (handlerState !== HandlerState.INITIALIZED) {\n    throw new Error('Network Request handler is not initialized');\n  }\n\n  const {rendererProcessesByFrame} = metaHandlerData();\n  for (const [requestId, request] of requestMap.entries()) {\n    // If we have an incomplete set of events here, we choose to drop the network\n    // request rather than attempt to synthesize the missing data.\n    if (!request.sendRequests || !request.receiveResponse) {\n      continue;\n    }\n\n    // In the data we may get multiple willSendRequests and sendRequests, which\n    // will indicate that there are redirects for a given (sub)resource. In the\n    // case of a navigation, e.g., example.com/ we will get willSendRequests,\n    // and we should use these to calculate time spent in redirects.\n    // In the case of subresources, however, e.g., example.com/foo.js we will\n    // *only* get sendRequests, and we use these instead of willSendRequests\n    // to detect the time in redirects. We always use the sendRequest for the\n    // url, priority etc since it contains those values, but we use the\n    // willSendRequest (if it exists) to calculate the timestamp and durations\n    // of redirects.\n    const redirects: Types.TraceEvents.TraceEventSyntheticNetworkRedirect[] = [];\n    for (let i = 0; i < request.sendRequests.length - 1; i++) {\n      const sendRequest = request.sendRequests[i];\n      const nextSendRequest = request.sendRequests[i + 1];\n\n      // Use the willSendRequests as the source for redirects if possible.\n      // We default to those of the sendRequests, however, since willSendRequest\n      // is not guaranteed to be present in the data for every request.\n      let ts = sendRequest.ts;\n      let dur = Types.Timing.MicroSeconds(nextSendRequest.ts - sendRequest.ts);\n      if (request.willSendRequests && request.willSendRequests[i] && request.willSendRequests[i + 1]) {\n        const willSendRequest = request.willSendRequests[i];\n        const nextWillSendRequest = request.willSendRequests[i + 1];\n        ts = willSendRequest.ts;\n        dur = Types.Timing.MicroSeconds(nextWillSendRequest.ts - willSendRequest.ts);\n      }\n\n      redirects.push({\n        url: sendRequest.args.data.url,\n        priority: sendRequest.args.data.priority,\n        ts,\n        dur,\n      });\n    }\n\n    const firstSendRequest = request.sendRequests[0];\n    const finalSendRequest = request.sendRequests[request.sendRequests.length - 1];\n    const {timing} = request.receiveResponse.args.data;\n    // No timing indicates data URLs, which we ignore.\n    if (!timing) {\n      continue;\n    }\n\n    // Start time\n    // =======================\n    // The time where the request started, which is either the first willSendRequest\n    // event if there is one, or, if there is not, the sendRequest.\n    const startTime = (request.willSendRequests && request.willSendRequests.length) ?\n        Types.Timing.MicroSeconds(request.willSendRequests[0].ts) :\n        Types.Timing.MicroSeconds(firstSendRequest.ts);\n\n    // End redirect time\n    // =======================\n    // It's possible that when we start requesting data we will receive redirections.\n    // Here we note the time of the *last* willSendRequest / sendRequest event,\n    // which is used later on in the calculations for time queueing etc.\n    const endRedirectTime = (request.willSendRequests && request.willSendRequests.length) ?\n        Types.Timing.MicroSeconds(request.willSendRequests[request.willSendRequests.length - 1].ts) :\n        Types.Timing.MicroSeconds(finalSendRequest.ts);\n\n    // Finsh time and end time\n    // =======================\n    // The finish time and the end time are subtly different.\n    //  - Finish time: records the point at which the network stack stopped receiving the data\n    //  - End time: the timestamp of the finish event itself (if one exists)\n    //\n    // The end time, then, will be slightly after the finish time.\n    const endTime = request.resourceFinish ? request.resourceFinish.ts : endRedirectTime;\n    const finishTime = request.resourceFinish ?\n        Types.Timing.MicroSeconds(request.resourceFinish.args.data.finishTime * SECONDS_TO_MICROSECONDS) :\n        Types.Timing.MicroSeconds(endTime);\n\n    // Network duration\n    // =======================\n    // Time spent on the network.\n    const networkDuration = Types.Timing.MicroSeconds((finishTime || endRedirectTime) - endRedirectTime);\n\n    // Processing duration\n    // =======================\n    // Time spent from start to end.\n    const processingDuration = Types.Timing.MicroSeconds(endTime - (finishTime || endTime));\n\n    // Redirection duration\n    // =======================\n    // Time between the first willSendRequest / sendRequest and last. This we place in *front* of the\n    // queueing, since the queueing time that we know about from the trace data is only the last request,\n    // i.e., the one that occurs after all the redirects.\n    const redirectionDuration = Types.Timing.MicroSeconds(endRedirectTime - startTime);\n\n    // Queueing\n    // =======================\n    // The amount of time queueing is the time between the request's start time to the requestTime\n    // arg recorded in the receiveResponse event. In the cases where the recorded start time is larger\n    // that the requestTime we set queueing time to zero.\n    const queueing = Types.Timing.MicroSeconds(Platform.NumberUtilities.clamp(\n        (timing.requestTime * SECONDS_TO_MICROSECONDS - endRedirectTime), 0, Number.MAX_VALUE));\n\n    // Stalled\n    // =======================\n    // The amount of time stalled is whichever positive number comes first from the\n    // following timing info: DNS start, Connection start, Send Start, or the time duration\n    // between our start time and receiving a response.\n    const stalled = Types.Timing.MicroSeconds(firstPositiveValueInList([\n      timing.dnsStart * MILLISECONDS_TO_MICROSECONDS,\n      timing.connectStart * MILLISECONDS_TO_MICROSECONDS,\n      timing.sendStart * MILLISECONDS_TO_MICROSECONDS,\n      (request.receiveResponse.ts - endRedirectTime),\n    ]));\n\n    // Waiting\n    // =======================\n    // Time from when the send finished going to when the headers were received.\n    const waiting =\n        Types.Timing.MicroSeconds((timing.receiveHeadersEnd - timing.sendEnd) * MILLISECONDS_TO_MICROSECONDS);\n\n    // Download\n    // =======================\n    // Time from receipt of headers to the finish time.\n    const downloadStart = Types.Timing.MicroSeconds(\n        timing.requestTime * SECONDS_TO_MICROSECONDS + timing.receiveHeadersEnd * MILLISECONDS_TO_MICROSECONDS);\n    const download = Types.Timing.MicroSeconds(((finishTime || downloadStart) - downloadStart));\n    const totalTime = Types.Timing.MicroSeconds(networkDuration + processingDuration);\n\n    // Collate a few values from the timing info.\n    const dnsLookup = Types.Timing.MicroSeconds((timing.dnsEnd - timing.dnsStart) * MILLISECONDS_TO_MICROSECONDS);\n    const ssl = Types.Timing.MicroSeconds((timing.sslEnd - timing.sslStart) * MILLISECONDS_TO_MICROSECONDS);\n    const proxyNegotiation =\n        Types.Timing.MicroSeconds((timing.proxyEnd - timing.proxyStart) * MILLISECONDS_TO_MICROSECONDS);\n    const requestSent = Types.Timing.MicroSeconds((timing.sendEnd - timing.sendStart) * MILLISECONDS_TO_MICROSECONDS);\n    const initialConnection =\n        Types.Timing.MicroSeconds((timing.connectEnd - timing.connectStart) * MILLISECONDS_TO_MICROSECONDS);\n\n    // Finally get some of the general data from the trace events.\n    const {priority, frame, url, renderBlocking} = finalSendRequest.args.data;\n    const {mimeType, fromCache, fromServiceWorker} = request.receiveResponse.args.data;\n    const {encodedDataLength, decodedBodyLength} =\n        request.resourceFinish ? request.resourceFinish.args.data : {encodedDataLength: 0, decodedBodyLength: 0};\n    const {receiveHeadersEnd, requestTime, sendEnd, sendStart, sslStart} = timing;\n    const {host, protocol, pathname, search} = new URL(url);\n    const isHttps = protocol === 'https:';\n    const renderProcesses = rendererProcessesByFrame.get(frame);\n    const processInfo = renderProcesses?.get(finalSendRequest.pid);\n    const requestingFrameUrl = processInfo ? processInfo.frame.url : '';\n\n    // Construct a synthetic trace event for this network request.\n    const networkEvent: Types.TraceEvents.TraceEventSyntheticNetworkRequest = {\n      args: {\n        data: {\n          decodedBodyLength,\n          dnsLookup,\n          download,\n          encodedDataLength,\n          finishTime,\n          frame,\n          fromCache,\n          fromServiceWorker,\n          initialConnection,\n          host,\n          isHttps,\n          mimeType,\n          networkDuration,\n          pathname,\n          search,\n          priority,\n          processingDuration,\n          protocol,\n          proxyNegotiation,\n          redirectionDuration,\n          queueing,\n          receiveHeadersEnd: Types.Timing.MicroSeconds(receiveHeadersEnd),\n          redirects,\n          requestId,\n          // In the event the property isn't set, assume non-blocking.\n          renderBlocking: renderBlocking ? renderBlocking : 'non_blocking',\n          requestSent,\n          requestTime,\n          requestingFrameUrl,\n          sendEnd: Types.Timing.MicroSeconds(sendEnd * MILLISECONDS_TO_MICROSECONDS),\n          sendStart: Types.Timing.MicroSeconds(sendStart * MILLISECONDS_TO_MICROSECONDS),\n          ssl,\n          sslStart: Types.Timing.MicroSeconds(sslStart * MILLISECONDS_TO_MICROSECONDS),\n          stalled,\n          statusCode: request.receiveResponse.args.data.statusCode,\n          stackTrace: finalSendRequest.args.data.stackTrace,\n          totalTime,\n          url,\n          waiting,\n        },\n      },\n      cat: 'loading',\n      name: 'SyntheticNetworkRequest',\n      ph: Types.TraceEvents.TraceEventPhase.COMPLETE,\n      dur: Types.Timing.MicroSeconds(endTime - startTime),\n      tdur: Types.Timing.MicroSeconds(endTime - startTime),\n      ts: Types.Timing.MicroSeconds(startTime),\n      tts: Types.Timing.MicroSeconds(startTime),\n      pid: finalSendRequest.pid,\n      tid: finalSendRequest.tid,\n    };\n\n    // The timing data returned is from the original (uncached) request,\n    // which means that if we leave the above network record data as-is\n    // when the request came from either the disk cache or memory cache,\n    // our calculations will be incorrect.\n    //\n    // Here we override the request data args based on the timestamps of the\n    // various events in the case where the fromCache flag is set to true.\n    // These timestamps may not be perfect (indeed they don't always match\n    // the Network CDP domain exactly, which is likely an artifact of the way\n    // the data is routed on the backend), but they're the closest we have.\n    if (networkEvent.args.data.fromCache) {\n      // Zero out the network-based timing info.\n      networkEvent.args.data.queueing = Types.Timing.MicroSeconds(0);\n      networkEvent.args.data.waiting = Types.Timing.MicroSeconds(0);\n      networkEvent.args.data.dnsLookup = Types.Timing.MicroSeconds(0);\n      networkEvent.args.data.initialConnection = Types.Timing.MicroSeconds(0);\n      networkEvent.args.data.ssl = Types.Timing.MicroSeconds(0);\n      networkEvent.args.data.requestSent = Types.Timing.MicroSeconds(0);\n      networkEvent.args.data.proxyNegotiation = Types.Timing.MicroSeconds(0);\n      networkEvent.args.data.networkDuration = Types.Timing.MicroSeconds(0);\n\n      // Update the stalled and download values.\n      const endStalled = request.receiveResponse ? request.receiveResponse.ts : startTime;\n      networkEvent.args.data.stalled = Types.Timing.MicroSeconds(endStalled - startTime);\n      networkEvent.args.data.download = Types.Timing.MicroSeconds(endTime - endStalled);\n    }\n\n    const requests = Platform.MapUtilities.getWithDefault(requestsByOrigin, host, () => {\n      return {\n        renderBlocking: [],\n        nonRenderBlocking: [],\n        all: [],\n      };\n    });\n\n    // For ease of rendering we sometimes want to differentiate between\n    // render-blocking and non-render-blocking, so we divide the data here.\n    if (networkEvent.args.data.renderBlocking === 'non_blocking') {\n      requests.nonRenderBlocking.push(networkEvent);\n    } else {\n      requests.renderBlocking.push(networkEvent);\n    }\n\n    // However, there are also times where we just want to loop through all\n    // the captured requests, so here we store all of them together.\n    requests.all.push(networkEvent);\n    requestsByTime.push(networkEvent);\n  }\n\n  handlerState = HandlerState.FINALIZED;\n}\n\nexport function data(): NetworkRequestData {\n  if (handlerState !== HandlerState.FINALIZED) {\n    throw new Error('Network Request handler is not finalized');\n  }\n\n  return {\n    byOrigin: new Map(requestsByOrigin),\n    byTime: [...requestsByTime],\n  };\n}\n\nexport function deps(): TraceEventHandlerName[] {\n  return ['Meta'];\n}\n"],
  "mappings": "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",
  "names": []
}
